.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFUNC 1"
.TH PERLFUNC 1 "2006-01-07" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
.IX Xref "function"
perlfunc \- Perl builtin functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in perlop.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar or list
contexts for its arguments.  If it does both, the scalar arguments will
be first, and the list argument will follow.  (Note that there can ever
be only one such list argument.)  For instance, \fIsplice()\fR has three scalar
arguments followed by a list, whereas \fIgethostbyname()\fR has four scalar
arguments.
.PP
In the syntax descriptions that follow, list operators that expect a
list (and provide list context for the elements of the list) are shown
with \s-1LIST\s0 as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Commas should separate elements of the \s-1LIST\s0.
.PP
Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parentheses.)  If you use the parentheses, the simple (but occasionally
surprising) rule is this: It \fIlooks\fR like a function, therefore it \fIis\fR a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  And whitespace
between the function and left parenthesis doesn't count\*(--so you need to
be careful sometimes:
.PP
.Vb 5
\&    print 1+2+4;        # Prints 7.
\&    print(1+2) + 4;     # Prints 3.
\&    print (1+2)+4;      # Also prints 3!
\&    print +(1+2)+4;     # Prints 7.
\&    print ((1+2)+4);    # Prints 7.
.Ve
.PP
If you run Perl with the \fB\-w\fR switch it can warn you about this.  For
example, the third line above produces:
.PP
.Vb 2
\&    print (...) interpreted as function at - line 1.
\&    Useless use of integer addition in void context at - line 1.
.Ve
.PP
A few functions take no arguments at all, and therefore work as neither
unary nor list operators.  These include such functions as \f(CW\*(C`time\*(C'\fR
and \f(CW\*(C`endpwent\*(C'\fR.  For example, \f(CW\*(C`time+86_400\*(C'\fR always means
\&\f(CW\*(C`time() + 86_400\*(C'\fR.
.PP
For functions that can be used in either a scalar or list context,
nonabortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
null list.
.PP
Remember the following important rule: There is \fBno rule\fR that relates
the behavior of an expression in list context to its behavior in scalar
context, or vice versa.  It might do two totally different things.
Each operator and function decides which sort of value it would be most
appropriate to return in scalar context.  Some operators return the
length of the list that would have been returned in list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
.IX Xref "context"
.PP
A named array in scalar context is quite different from what would at
first glance appear to be a list in scalar context.  You can't get a list
like \f(CW\*(C`(1,2,3)\*(C'\fR into being in scalar context, because the compiler knows
the context at compile time.  It would generate the scalar comma operator
there, not the list construction version of the comma.  That means it
was never a list to start with.
.PP
In general, functions in Perl that serve as wrappers for system calls
of the same name (like \fIchown\fR\|(2), \fIfork\fR\|(2), \fIclosedir\fR\|(2), etc.) all return
true when they succeed and \f(CW\*(C`undef\*(C'\fR otherwise, as is usually mentioned
in the descriptions below.  This is different from the C interfaces,
which return \f(CW\*(C`\-1\*(C'\fR on failure.  Exceptions to this rule are \f(CW\*(C`wait\*(C'\fR,
\&\f(CW\*(C`waitpid\*(C'\fR, and \f(CW\*(C`syscall\*(C'\fR.  System calls also set the special \f(CW$!\fR
variable on failure.  Other functions do not, except accidentally.
.Sh "Perl Functions by Category"
.IX Xref "function"
.IX Subsection "Perl Functions by Category"
Here are Perl's functions (including things that look like
functions, like some keywords and named operators)
arranged by category.  Some functions appear in more
than one place.
.IP "Functions for SCALARs or strings" 4
.IX Xref "scalar string character"
.IX Item "Functions for SCALARs or strings"
\&\f(CW\*(C`chomp\*(C'\fR, \f(CW\*(C`chop\*(C'\fR, \f(CW\*(C`chr\*(C'\fR, \f(CW\*(C`crypt\*(C'\fR, \f(CW\*(C`hex\*(C'\fR, \f(CW\*(C`index\*(C'\fR, \f(CW\*(C`lc\*(C'\fR, \f(CW\*(C`lcfirst\*(C'\fR,
\&\f(CW\*(C`length\*(C'\fR, \f(CW\*(C`oct\*(C'\fR, \f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`q/STRING/\*(C'\fR, \f(CW\*(C`qq/STRING/\*(C'\fR, \f(CW\*(C`reverse\*(C'\fR,
\&\f(CW\*(C`rindex\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`substr\*(C'\fR, \f(CW\*(C`tr///\*(C'\fR, \f(CW\*(C`uc\*(C'\fR, \f(CW\*(C`ucfirst\*(C'\fR, \f(CW\*(C`y///\*(C'\fR
.IP "Regular expressions and pattern matching" 4
.IX Xref "regular expression regex regexp"
.IX Item "Regular expressions and pattern matching"
\&\f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`pos\*(C'\fR, \f(CW\*(C`quotemeta\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`split\*(C'\fR, \f(CW\*(C`study\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR
.IP "Numeric functions" 4
.IX Xref "numeric number trigonometric trigonometry"
.IX Item "Numeric functions"
\&\f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`atan2\*(C'\fR, \f(CW\*(C`cos\*(C'\fR, \f(CW\*(C`exp\*(C'\fR, \f(CW\*(C`hex\*(C'\fR, \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`log\*(C'\fR, \f(CW\*(C`oct\*(C'\fR, \f(CW\*(C`rand\*(C'\fR,
\&\f(CW\*(C`sin\*(C'\fR, \f(CW\*(C`sqrt\*(C'\fR, \f(CW\*(C`srand\*(C'\fR
.ie n .IP "Functions for real @ARRAYs" 4
.el .IP "Functions for real \f(CW@ARRAYs\fR" 4
.IX Xref "array"
.IX Item "Functions for real @ARRAYs"
\&\f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`splice\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR
.IP "Functions for list data" 4
.IX Xref "list"
.IX Item "Functions for list data"
\&\f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`join\*(C'\fR, \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`qw/STRING/\*(C'\fR, \f(CW\*(C`reverse\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR
.ie n .IP "Functions for real %HASHes" 4
.el .IP "Functions for real \f(CW%HASHes\fR" 4
.IX Xref "hash"
.IX Item "Functions for real %HASHes"
\&\f(CW\*(C`delete\*(C'\fR, \f(CW\*(C`each\*(C'\fR, \f(CW\*(C`exists\*(C'\fR, \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR
.IP "Input and output functions" 4
.IX Xref "I O input output dbm"
.IX Item "Input and output functions"
\&\f(CW\*(C`binmode\*(C'\fR, \f(CW\*(C`close\*(C'\fR, \f(CW\*(C`closedir\*(C'\fR, \f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR, \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`eof\*(C'\fR,
\&\f(CW\*(C`fileno\*(C'\fR, \f(CW\*(C`flock\*(C'\fR, \f(CW\*(C`format\*(C'\fR, \f(CW\*(C`getc\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`read\*(C'\fR,
\&\f(CW\*(C`readdir\*(C'\fR, \f(CW\*(C`rewinddir\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, \f(CW\*(C`seekdir\*(C'\fR, \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`syscall\*(C'\fR,
\&\f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysseek\*(C'\fR, \f(CW\*(C`syswrite\*(C'\fR, \f(CW\*(C`tell\*(C'\fR, \f(CW\*(C`telldir\*(C'\fR, \f(CW\*(C`truncate\*(C'\fR,
\&\f(CW\*(C`warn\*(C'\fR, \f(CW\*(C`write\*(C'\fR
.IP "Functions for fixed length data or records" 4
.IX Item "Functions for fixed length data or records"
\&\f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`syscall\*(C'\fR, \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`syswrite\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR, \f(CW\*(C`vec\*(C'\fR
.IP "Functions for filehandles, files, or directories" 4
.IX Xref "file filehandle directory pipe link symlink"
.IX Item "Functions for filehandles, files, or directories"
\&\f(CW\*(C`\-\f(CIX\f(CW\*(C'\fR, \f(CW\*(C`chdir\*(C'\fR, \f(CW\*(C`chmod\*(C'\fR, \f(CW\*(C`chown\*(C'\fR, \f(CW\*(C`chroot\*(C'\fR, \f(CW\*(C`fcntl\*(C'\fR, \f(CW\*(C`glob\*(C'\fR,
\&\f(CW\*(C`ioctl\*(C'\fR, \f(CW\*(C`link\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR, \f(CW\*(C`mkdir\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`opendir\*(C'\fR,
\&\f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`rename\*(C'\fR, \f(CW\*(C`rmdir\*(C'\fR, \f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR,
\&\f(CW\*(C`umask\*(C'\fR, \f(CW\*(C`unlink\*(C'\fR, \f(CW\*(C`utime\*(C'\fR
.IP "Keywords related to the control flow of your Perl program" 4
.IX Xref "control flow"
.IX Item "Keywords related to the control flow of your Perl program"
\&\f(CW\*(C`caller\*(C'\fR, \f(CW\*(C`continue\*(C'\fR, \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`do\*(C'\fR, \f(CW\*(C`dump\*(C'\fR, \f(CW\*(C`eval\*(C'\fR, \f(CW\*(C`exit\*(C'\fR,
\&\f(CW\*(C`goto\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`redo\*(C'\fR, \f(CW\*(C`return\*(C'\fR, \f(CW\*(C`sub\*(C'\fR, \f(CW\*(C`wantarray\*(C'\fR
.IP "Keywords related to scoping" 4
.IX Item "Keywords related to scoping"
\&\f(CW\*(C`caller\*(C'\fR, \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`our\*(C'\fR, \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.IP "Miscellaneous functions" 4
.IX Item "Miscellaneous functions"
\&\f(CW\*(C`defined\*(C'\fR, \f(CW\*(C`dump\*(C'\fR, \f(CW\*(C`eval\*(C'\fR, \f(CW\*(C`formline\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`our\*(C'\fR, \f(CW\*(C`reset\*(C'\fR,
\&\f(CW\*(C`scalar\*(C'\fR, \f(CW\*(C`undef\*(C'\fR, \f(CW\*(C`wantarray\*(C'\fR
.IP "Functions for processes and process groups" 4
.IX Xref "process pid process id"
.IX Item "Functions for processes and process groups"
\&\f(CW\*(C`alarm\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`getpgrp\*(C'\fR, \f(CW\*(C`getppid\*(C'\fR, \f(CW\*(C`getpriority\*(C'\fR, \f(CW\*(C`kill\*(C'\fR,
\&\f(CW\*(C`pipe\*(C'\fR, \f(CW\*(C`qx/STRING/\*(C'\fR, \f(CW\*(C`setpgrp\*(C'\fR, \f(CW\*(C`setpriority\*(C'\fR, \f(CW\*(C`sleep\*(C'\fR, \f(CW\*(C`system\*(C'\fR,
\&\f(CW\*(C`times\*(C'\fR, \f(CW\*(C`wait\*(C'\fR, \f(CW\*(C`waitpid\*(C'\fR
.IP "Keywords related to perl modules" 4
.IX Xref "module"
.IX Item "Keywords related to perl modules"
\&\f(CW\*(C`do\*(C'\fR, \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`require\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.IP "Keywords related to classes and object-orientedness" 4
.IX Xref "object class package"
.IX Item "Keywords related to classes and object-orientedness"
\&\f(CW\*(C`bless\*(C'\fR, \f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR, \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`ref\*(C'\fR, \f(CW\*(C`tie\*(C'\fR, \f(CW\*(C`tied\*(C'\fR,
\&\f(CW\*(C`untie\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.IP "Low-level socket functions" 4
.IX Xref "socket sock"
.IX Item "Low-level socket functions"
\&\f(CW\*(C`accept\*(C'\fR, \f(CW\*(C`bind\*(C'\fR, \f(CW\*(C`connect\*(C'\fR, \f(CW\*(C`getpeername\*(C'\fR, \f(CW\*(C`getsockname\*(C'\fR,
\&\f(CW\*(C`getsockopt\*(C'\fR, \f(CW\*(C`listen\*(C'\fR, \f(CW\*(C`recv\*(C'\fR, \f(CW\*(C`send\*(C'\fR, \f(CW\*(C`setsockopt\*(C'\fR, \f(CW\*(C`shutdown\*(C'\fR,
\&\f(CW\*(C`socket\*(C'\fR, \f(CW\*(C`socketpair\*(C'\fR
.IP "System V interprocess communication functions" 4
.IX Xref "IPC System V semaphore shared memory memory message"
.IX Item "System V interprocess communication functions"
\&\f(CW\*(C`msgctl\*(C'\fR, \f(CW\*(C`msgget\*(C'\fR, \f(CW\*(C`msgrcv\*(C'\fR, \f(CW\*(C`msgsnd\*(C'\fR, \f(CW\*(C`semctl\*(C'\fR, \f(CW\*(C`semget\*(C'\fR, \f(CW\*(C`semop\*(C'\fR,
\&\f(CW\*(C`shmctl\*(C'\fR, \f(CW\*(C`shmget\*(C'\fR, \f(CW\*(C`shmread\*(C'\fR, \f(CW\*(C`shmwrite\*(C'\fR
.IP "Fetching user and group info" 4
.IX Xref "user group password uid gid passwd  etc passwd"
.IX Item "Fetching user and group info"
\&\f(CW\*(C`endgrent\*(C'\fR, \f(CW\*(C`endhostent\*(C'\fR, \f(CW\*(C`endnetent\*(C'\fR, \f(CW\*(C`endpwent\*(C'\fR, \f(CW\*(C`getgrent\*(C'\fR,
\&\f(CW\*(C`getgrgid\*(C'\fR, \f(CW\*(C`getgrnam\*(C'\fR, \f(CW\*(C`getlogin\*(C'\fR, \f(CW\*(C`getpwent\*(C'\fR, \f(CW\*(C`getpwnam\*(C'\fR,
\&\f(CW\*(C`getpwuid\*(C'\fR, \f(CW\*(C`setgrent\*(C'\fR, \f(CW\*(C`setpwent\*(C'\fR
.IP "Fetching network info" 4
.IX Xref "network protocol host hostname IP address service"
.IX Item "Fetching network info"
\&\f(CW\*(C`endprotoent\*(C'\fR, \f(CW\*(C`endservent\*(C'\fR, \f(CW\*(C`gethostbyaddr\*(C'\fR, \f(CW\*(C`gethostbyname\*(C'\fR,
\&\f(CW\*(C`gethostent\*(C'\fR, \f(CW\*(C`getnetbyaddr\*(C'\fR, \f(CW\*(C`getnetbyname\*(C'\fR, \f(CW\*(C`getnetent\*(C'\fR,
\&\f(CW\*(C`getprotobyname\*(C'\fR, \f(CW\*(C`getprotobynumber\*(C'\fR, \f(CW\*(C`getprotoent\*(C'\fR,
\&\f(CW\*(C`getservbyname\*(C'\fR, \f(CW\*(C`getservbyport\*(C'\fR, \f(CW\*(C`getservent\*(C'\fR, \f(CW\*(C`sethostent\*(C'\fR,
\&\f(CW\*(C`setnetent\*(C'\fR, \f(CW\*(C`setprotoent\*(C'\fR, \f(CW\*(C`setservent\*(C'\fR
.IP "Time-related functions" 4
.IX Xref "time date"
.IX Item "Time-related functions"
\&\f(CW\*(C`gmtime\*(C'\fR, \f(CW\*(C`localtime\*(C'\fR, \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`times\*(C'\fR
.IP "Functions new in perl5" 4
.IX Xref "perl5"
.IX Item "Functions new in perl5"
\&\f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`bless\*(C'\fR, \f(CW\*(C`chomp\*(C'\fR, \f(CW\*(C`chr\*(C'\fR, \f(CW\*(C`exists\*(C'\fR, \f(CW\*(C`formline\*(C'\fR, \f(CW\*(C`glob\*(C'\fR,
\&\f(CW\*(C`import\*(C'\fR, \f(CW\*(C`lc\*(C'\fR, \f(CW\*(C`lcfirst\*(C'\fR, \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`our\*(C'\fR, \f(CW\*(C`prototype\*(C'\fR,
\&\f(CW\*(C`qx\*(C'\fR, \f(CW\*(C`qw\*(C'\fR, \f(CW\*(C`readline\*(C'\fR, \f(CW\*(C`readpipe\*(C'\fR, \f(CW\*(C`ref\*(C'\fR, \f(CW\*(C`sub*\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \f(CW\*(C`tie\*(C'\fR,
\&\f(CW\*(C`tied\*(C'\fR, \f(CW\*(C`uc\*(C'\fR, \f(CW\*(C`ucfirst\*(C'\fR, \f(CW\*(C`untie\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.Sp
* \- \f(CW\*(C`sub\*(C'\fR was a keyword in perl4, but in perl5 it is an
operator, which can be used in expressions.
.IP "Functions obsoleted in perl5" 4
.IX Item "Functions obsoleted in perl5"
\&\f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR
.Sh "Portability"
.IX Xref "portability Unix portable"
.IX Subsection "Portability"
Perl was born in Unix and can therefore access all common Unix
system calls.  In non-Unix environments, the functionality of some
Unix system calls may not be available, or details of the available
functionality may differ slightly.  The Perl functions affected
by this are:
.PP
\&\f(CW\*(C`\-X\*(C'\fR, \f(CW\*(C`binmode\*(C'\fR, \f(CW\*(C`chmod\*(C'\fR, \f(CW\*(C`chown\*(C'\fR, \f(CW\*(C`chroot\*(C'\fR, \f(CW\*(C`crypt\*(C'\fR,
\&\f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR, \f(CW\*(C`dump\*(C'\fR, \f(CW\*(C`endgrent\*(C'\fR, \f(CW\*(C`endhostent\*(C'\fR,
\&\f(CW\*(C`endnetent\*(C'\fR, \f(CW\*(C`endprotoent\*(C'\fR, \f(CW\*(C`endpwent\*(C'\fR, \f(CW\*(C`endservent\*(C'\fR, \f(CW\*(C`exec\*(C'\fR,
\&\f(CW\*(C`fcntl\*(C'\fR, \f(CW\*(C`flock\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`getgrent\*(C'\fR, \f(CW\*(C`getgrgid\*(C'\fR, \f(CW\*(C`gethostbyname\*(C'\fR,
\&\f(CW\*(C`gethostent\*(C'\fR, \f(CW\*(C`getlogin\*(C'\fR, \f(CW\*(C`getnetbyaddr\*(C'\fR, \f(CW\*(C`getnetbyname\*(C'\fR, \f(CW\*(C`getnetent\*(C'\fR,
\&\f(CW\*(C`getppid\*(C'\fR, \f(CW\*(C`getpgrp\*(C'\fR, \f(CW\*(C`getpriority\*(C'\fR, \f(CW\*(C`getprotobynumber\*(C'\fR,
\&\f(CW\*(C`getprotoent\*(C'\fR, \f(CW\*(C`getpwent\*(C'\fR, \f(CW\*(C`getpwnam\*(C'\fR, \f(CW\*(C`getpwuid\*(C'\fR,
\&\f(CW\*(C`getservbyport\*(C'\fR, \f(CW\*(C`getservent\*(C'\fR, \f(CW\*(C`getsockopt\*(C'\fR, \f(CW\*(C`glob\*(C'\fR, \f(CW\*(C`ioctl\*(C'\fR,
\&\f(CW\*(C`kill\*(C'\fR, \f(CW\*(C`link\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR, \f(CW\*(C`msgctl\*(C'\fR, \f(CW\*(C`msgget\*(C'\fR, \f(CW\*(C`msgrcv\*(C'\fR,
\&\f(CW\*(C`msgsnd\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`pipe\*(C'\fR, \f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`rename\*(C'\fR, \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`semctl\*(C'\fR,
\&\f(CW\*(C`semget\*(C'\fR, \f(CW\*(C`semop\*(C'\fR, \f(CW\*(C`setgrent\*(C'\fR, \f(CW\*(C`sethostent\*(C'\fR, \f(CW\*(C`setnetent\*(C'\fR,
\&\f(CW\*(C`setpgrp\*(C'\fR, \f(CW\*(C`setpriority\*(C'\fR, \f(CW\*(C`setprotoent\*(C'\fR, \f(CW\*(C`setpwent\*(C'\fR,
\&\f(CW\*(C`setservent\*(C'\fR, \f(CW\*(C`setsockopt\*(C'\fR, \f(CW\*(C`shmctl\*(C'\fR, \f(CW\*(C`shmget\*(C'\fR, \f(CW\*(C`shmread\*(C'\fR,
\&\f(CW\*(C`shmwrite\*(C'\fR, \f(CW\*(C`socket\*(C'\fR, \f(CW\*(C`socketpair\*(C'\fR,
\&\f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`syscall\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \f(CW\*(C`system\*(C'\fR,
\&\f(CW\*(C`times\*(C'\fR, \f(CW\*(C`truncate\*(C'\fR, \f(CW\*(C`umask\*(C'\fR, \f(CW\*(C`unlink\*(C'\fR,
\&\f(CW\*(C`utime\*(C'\fR, \f(CW\*(C`wait\*(C'\fR, \f(CW\*(C`waitpid\*(C'\fR
.PP
For more information about the portability of these functions, see
perlport and other available platform-specific documentation.
.Sh "Alphabetical Listing of Perl Functions"
.IX Subsection "Alphabetical Listing of Perl Functions"
.IP "\-X \s-1FILEHANDLE\s0" 8
.IX Xref "-r -w -x -o -R -W -X -O -e -z -s -f -d -l -p -S -b -c -t -u -g -k -T -B -M -A -C"
.IX Item "-X FILEHANDLE"
.PD 0
.IP "\-X \s-1EXPR\s0" 8
.IX Item "-X EXPR"
.IP "\-X" 8
.IX Item "-X"
.PD
A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename or a filehandle, and
tests the associated file to see if something is true about it.  If the
argument is omitted, tests \f(CW$_\fR, except for \f(CW\*(C`\-t\*(C'\fR, which tests \s-1STDIN\s0.
Unless otherwise documented, it returns \f(CW1\fR for true and \f(CW''\fR for false, or
the undefined value if the file doesn't exist.  Despite the funny
names, precedence is the same as any other named unary operator, and
the argument may be parenthesized like any other unary operator.  The
operator may be any of:
.Sp
.Vb 4
\&    -r  File is readable by effective uid/gid.
\&    -w  File is writable by effective uid/gid.
\&    -x  File is executable by effective uid/gid.
\&    -o  File is owned by effective uid.
.Ve
.Sp
.Vb 4
\&    -R  File is readable by real uid/gid.
\&    -W  File is writable by real uid/gid.
\&    -X  File is executable by real uid/gid.
\&    -O  File is owned by real uid.
.Ve
.Sp
.Vb 3
\&    -e  File exists.
\&    -z  File has zero size (is empty).
\&    -s  File has nonzero size (returns size in bytes).
.Ve
.Sp
.Vb 8
\&    -f  File is a plain file.
\&    -d  File is a directory.
\&    -l  File is a symbolic link.
\&    -p  File is a named pipe (FIFO), or Filehandle is a pipe.
\&    -S  File is a socket.
\&    -b  File is a block special file.
\&    -c  File is a character special file.
\&    -t  Filehandle is opened to a tty.
.Ve
.Sp
.Vb 3
\&    -u  File has setuid bit set.
\&    -g  File has setgid bit set.
\&    -k  File has sticky bit set.
.Ve
.Sp
.Vb 2
\&    -T  File is an ASCII text file (heuristic guess).
\&    -B  File is a "binary" file (opposite of -T).
.Ve
.Sp
.Vb 3
\&    -M  Script start time minus file modification time, in days.
\&    -A  Same for access time.
\&    -C  Same for inode change time (Unix, may differ for other platforms)
.Ve
.Sp
Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chomp;
\&        next unless -f $_;      # ignore specials
\&        #...
\&    }
.Ve
.Sp
The interpretation of the file permission operators \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-R\*(C'\fR,
\&\f(CW\*(C`\-w\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, and \f(CW\*(C`\-X\*(C'\fR is by default based solely on the mode
of the file and the uids and gids of the user.  There may be other
reasons you can't actually read, write, or execute the file.  Such
reasons may be for example network filesystem access controls, ACLs
(access control lists), read-only filesystems, and unrecognized
executable formats.
.Sp
Also note that, for the superuser on the local filesystems, the \f(CW\*(C`\-r\*(C'\fR,
\&\f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, and \f(CW\*(C`\-W\*(C'\fR tests always return 1, and \f(CW\*(C`\-x\*(C'\fR and \f(CW\*(C`\-X\*(C'\fR return 1
if any execute bit is set in the mode.  Scripts run by the superuser
may thus need to do a \fIstat()\fR to determine the actual mode of the file,
or temporarily set their effective uid to something else.
.Sp
If you are using ACLs, there is a pragma called \f(CW\*(C`filetest\*(C'\fR that may
produce more accurate results than the bare \fIstat()\fR mode bits.
When under the \f(CW\*(C`use filetest 'access'\*(C'\fR the above-mentioned filetests
will test whether the permission can (not) be granted using the
\&\fIaccess()\fR family of system calls.  Also note that the \f(CW\*(C`\-x\*(C'\fR and \f(CW\*(C`\-X\*(C'\fR may
under this pragma return true even if there are no execute permission
bits set (nor any extra execute permission ACLs).  This strangeness is
due to the underlying system calls' definitions.  Read the
documentation for the \f(CW\*(C`filetest\*(C'\fR pragma for more information.
.Sp
Note that \f(CW\*(C`\-s/a/b/\*(C'\fR does not do a negated substitution.  Saying
\&\f(CW\*(C`\-exp($foo)\*(C'\fR still works as expected, however\*(--only single letters
following a minus are interpreted as file tests.
.Sp
The \f(CW\*(C`\-T\*(C'\fR and \f(CW\*(C`\-B\*(C'\fR switches work as follows.  The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many strange characters (>30%)
are found, it's a \f(CW\*(C`\-B\*(C'\fR file; otherwise it's a \f(CW\*(C`\-T\*(C'\fR file.  Also, any file
containing null in the first block is considered a binary file.  If \f(CW\*(C`\-T\*(C'\fR
or \f(CW\*(C`\-B\*(C'\fR is used on a filehandle, the current \s-1IO\s0 buffer is examined
rather than the first block.  Both \f(CW\*(C`\-T\*(C'\fR and \f(CW\*(C`\-B\*(C'\fR return true on a null
file, or a file at \s-1EOF\s0 when testing a filehandle.  Because you have to
read a file to do the \f(CW\*(C`\-T\*(C'\fR test, on most occasions you want to use a \f(CW\*(C`\-f\*(C'\fR
against the file first, as in \f(CW\*(C`next unless \-f $file && \-T $file\*(C'\fR.
.Sp
If any of the file tests (or either the \f(CW\*(C`stat\*(C'\fR or \f(CW\*(C`lstat\*(C'\fR operators) are given
the special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.  (This doesn't work with \f(CW\*(C`\-t\*(C'\fR, and you need to remember
that \fIlstat()\fR and \f(CW\*(C`\-l\*(C'\fR will leave values in the stat structure for the
symbolic link, not the real file.)  (Also, if the stat buffer was filled by
an \f(CW\*(C`lstat\*(C'\fR call, \f(CW\*(C`\-T\*(C'\fR and \f(CW\*(C`\-B\*(C'\fR will reset it with the results of \f(CW\*(C`stat _\*(C'\fR).
Example:
.Sp
.Vb 1
\&    print "Can do.\en" if -r $a || -w _ || -x _;
.Ve
.Sp
.Vb 9
\&    stat($filename);
\&    print "Readable\en" if -r _;
\&    print "Writable\en" if -w _;
\&    print "Executable\en" if -x _;
\&    print "Setuid\en" if -u _;
\&    print "Setgid\en" if -g _;
\&    print "Sticky\en" if -k _;
\&    print "Text\en" if -T _;
\&    print "Binary\en" if -B _;
.Ve
.IP "abs \s-1VALUE\s0" 8
.IX Xref "abs absolute"
.IX Item "abs VALUE"
.PD 0
.IP "abs" 8
.IX Item "abs"
.PD
Returns the absolute value of its argument.
If \s-1VALUE\s0 is omitted, uses \f(CW$_\fR.
.IP "accept \s-1NEWSOCKET\s0,GENERICSOCKET" 8
.IX Xref "accept"
.IX Item "accept NEWSOCKET,GENERICSOCKET"
Accepts an incoming socket connect, just as the \fIaccept\fR\|(2) system call
does.  Returns the packed address if it succeeded, false otherwise.
See the example in \*(L"Sockets: Client/Server Communication\*(R" in perlipc.
.Sp
On systems that support a close-on-exec flag on files, the flag will
be set for the newly opened file descriptor, as determined by the
value of $^F.  See \*(L"$^F\*(R" in perlvar.
.IP "alarm \s-1SECONDS\s0" 8
.IX Xref "alarm SIGALRM timer"
.IX Item "alarm SECONDS"
.PD 0
.IP "alarm" 8
.IX Item "alarm"
.PD
Arranges to have a \s-1SIGALRM\s0 delivered to this process after the
specified number of wallclock seconds has elapsed.  If \s-1SECONDS\s0 is not
specified, the value stored in \f(CW$_\fR is used. (On some machines,
unfortunately, the elapsed time may be up to one second less or more
than you specified because of how seconds are counted, and process
scheduling may delay the delivery of the signal even further.)
.Sp
Only one timer may be counting at once.  Each call disables the
previous timer, and an argument of \f(CW0\fR may be supplied to cancel the
previous timer without starting a new one.  The returned value is the
amount of time remaining on the previous timer.
.Sp
For delays of finer granularity than one second, you may use Perl's
four-argument version of \fIselect()\fR leaving the first three arguments
undefined, or you might be able to use the \f(CW\*(C`syscall\*(C'\fR interface to
access \fIsetitimer\fR\|(2) if your system supports it.  The Time::HiRes
module (from \s-1CPAN\s0, and starting from Perl 5.8 part of the standard
distribution) may also prove useful.
.Sp
It is usually a mistake to intermix \f(CW\*(C`alarm\*(C'\fR and \f(CW\*(C`sleep\*(C'\fR calls.
(\f(CW\*(C`sleep\*(C'\fR may be internally implemented in your system with \f(CW\*(C`alarm\*(C'\fR)
.Sp
If you want to use \f(CW\*(C`alarm\*(C'\fR to time out a system call you need to use an
\&\f(CW\*(C`eval\*(C'\fR/\f(CW\*(C`die\*(C'\fR pair.  You can't rely on the alarm causing the system call to
fail with \f(CW$!\fR set to \f(CW\*(C`EINTR\*(C'\fR because Perl sets up signal handlers to
restart system calls on some systems.  Using \f(CW\*(C`eval\*(C'\fR/\f(CW\*(C`die\*(C'\fR always works,
modulo the caveats given in \*(L"Signals\*(R" in perlipc.
.Sp
.Vb 13
\&    eval {
\&        local $SIG{ALRM} = sub { die "alarm\en" }; # NB: \en required
\&        alarm $timeout;
\&        $nread = sysread SOCKET, $buffer, $size;
\&        alarm 0;
\&    };
\&    if ($@) {
\&        die unless $@ eq "alarm\en";   # propagate unexpected errors
\&        # timed out
\&    }
\&    else {
\&        # didn't
\&    }
.Ve
.Sp
For more information see perlipc.
.IP "atan2 Y,X" 8
.IX Xref "atan2 arctangent tan tangent"
.IX Item "atan2 Y,X"
Returns the arctangent of Y/X in the range \-PI to \s-1PI\s0.
.Sp
For the tangent operation, you may use the \f(CW\*(C`Math::Trig::tan\*(C'\fR
function, or use the familiar relation:
.Sp
.Vb 1
\&    sub tan { sin($_[0]) / cos($_[0])  }
.Ve
.Sp
Note that atan2(0, 0) is not well\-defined.
.IP "bind \s-1SOCKET\s0,NAME" 8
.IX Xref "bind"
.IX Item "bind SOCKET,NAME"
Binds a network address to a socket, just as the bind system call
does.  Returns true if it succeeded, false otherwise.  \s-1NAME\s0 should be a
packed address of the appropriate type for the socket.  See the examples in
\&\*(L"Sockets: Client/Server Communication\*(R" in perlipc.
.IP "binmode \s-1FILEHANDLE\s0, \s-1LAYER\s0" 8
.IX Xref "binmode binary text DOS Windows"
.IX Item "binmode FILEHANDLE, LAYER"
.PD 0
.IP "binmode \s-1FILEHANDLE\s0" 8
.IX Item "binmode FILEHANDLE"
.PD
Arranges for \s-1FILEHANDLE\s0 to be read or written in \*(L"binary\*(R" or \*(L"text\*(R"
mode on systems where the run-time libraries distinguish between
binary and text files.  If \s-1FILEHANDLE\s0 is an expression, the value is
taken as the name of the filehandle.  Returns true on success,
otherwise it returns \f(CW\*(C`undef\*(C'\fR and sets \f(CW$!\fR (errno).
.Sp
On some systems (in general, \s-1DOS\s0 and Windows-based systems) \fIbinmode()\fR
is necessary when you're not working with a text file.  For the sake
of portability it is a good idea to always use it when appropriate,
and to never use it when it isn't appropriate.  Also, people can
set their I/O to be by default \s-1UTF\-8\s0 encoded Unicode, not bytes.
.Sp
In other words: regardless of platform, use \fIbinmode()\fR on binary data,
like for example images.
.Sp
If \s-1LAYER\s0 is present it is a single string, but may contain multiple
directives. The directives alter the behaviour of the file handle.
When \s-1LAYER\s0 is present using binmode on text file makes sense.
.Sp
If \s-1LAYER\s0 is omitted or specified as \f(CW\*(C`:raw\*(C'\fR the filehandle is made
suitable for passing binary data. This includes turning off possible \s-1CRLF\s0
translation and marking it as bytes (as opposed to Unicode characters).
Note that, despite what may be implied in \fI\*(L"Programming Perl\*(R"\fR (the
Camel) or elsewhere, \f(CW\*(C`:raw\*(C'\fR is \fInot\fR the simply inverse of \f(CW\*(C`:crlf\*(C'\fR
\&\*(-- other layers which would affect binary nature of the stream are
\&\fIalso\fR disabled. See PerlIO, perlrun and the discussion about the
\&\s-1PERLIO\s0 environment variable.
.Sp
The \f(CW\*(C`:bytes\*(C'\fR, \f(CW\*(C`:crlf\*(C'\fR, and \f(CW\*(C`:utf8\*(C'\fR, and any other directives of the
form \f(CW\*(C`:...\*(C'\fR, are called I/O \fIlayers\fR.  The \f(CW\*(C`open\*(C'\fR pragma can be used to
establish default I/O layers.  See open.
.Sp
\&\fIThe \s-1LAYER\s0 parameter of the \fIbinmode()\fI function is described as \*(L"\s-1DISCIPLINE\s0\*(R"
in \*(L"Programming Perl, 3rd Edition\*(R".  However, since the publishing of this
book, by many known as \*(L"Camel \s-1III\s0\*(R", the consensus of the naming of this
functionality has moved from \*(L"discipline\*(R" to \*(L"layer\*(R".  All documentation
of this version of Perl therefore refers to \*(L"layers\*(R" rather than to
\&\*(L"disciplines\*(R".  Now back to the regularly scheduled documentation...\fR
.Sp
To mark \s-1FILEHANDLE\s0 as \s-1UTF\-8\s0, use \f(CW\*(C`:utf8\*(C'\fR.
.Sp
In general, \fIbinmode()\fR should be called after \fIopen()\fR but before any I/O
is done on the filehandle.  Calling \fIbinmode()\fR will normally flush any
pending buffered output data (and perhaps pending input data) on the
handle.  An exception to this is the \f(CW\*(C`:encoding\*(C'\fR layer that
changes the default character encoding of the handle, see open.
The \f(CW\*(C`:encoding\*(C'\fR layer sometimes needs to be called in
mid\-stream, and it doesn't flush the stream.  The \f(CW\*(C`:encoding\*(C'\fR
also implicitly pushes on top of itself the \f(CW\*(C`:utf8\*(C'\fR layer because
internally Perl will operate on \s-1UTF\-8\s0 encoded Unicode characters.
.Sp
The operating system, device drivers, C libraries, and Perl run-time
system all work together to let the programmer treat a single
character (\f(CW\*(C`\en\*(C'\fR) as the line terminator, irrespective of the external
representation.  On many operating systems, the native text file
representation matches the internal representation, but on some
platforms the external representation of \f(CW\*(C`\en\*(C'\fR is made up of more than
one character.
.Sp
Mac \s-1OS\s0, all variants of Unix, and Stream_LF files on \s-1VMS\s0 use a single
character to end each line in the external representation of text (even
though that single character is \s-1CARRIAGE\s0 \s-1RETURN\s0 on Mac \s-1OS\s0 and \s-1LINE\s0 \s-1FEED\s0
on Unix and most \s-1VMS\s0 files). In other systems like \s-1OS/2\s0, \s-1DOS\s0 and the
various flavors of MS-Windows your program sees a \f(CW\*(C`\en\*(C'\fR as a simple \f(CW\*(C`\ecJ\*(C'\fR,
but what's stored in text files are the two characters \f(CW\*(C`\ecM\ecJ\*(C'\fR.  That
means that, if you don't use \fIbinmode()\fR on these systems, \f(CW\*(C`\ecM\ecJ\*(C'\fR
sequences on disk will be converted to \f(CW\*(C`\en\*(C'\fR on input, and any \f(CW\*(C`\en\*(C'\fR in
your program will be converted back to \f(CW\*(C`\ecM\ecJ\*(C'\fR on output.  This is what
you want for text files, but it can be disastrous for binary files.
.Sp
Another consequence of using \fIbinmode()\fR (on some systems) is that
special end-of-file markers will be seen as part of the data stream.
For systems from the Microsoft family this means that if your binary
data contains \f(CW\*(C`\ecZ\*(C'\fR, the I/O subsystem will regard it as the end of
the file, unless you use \fIbinmode()\fR.
.Sp
\&\fIbinmode()\fR is not only important for \fIreadline()\fR and \fIprint()\fR operations,
but also when using \fIread()\fR, \fIseek()\fR, \fIsysread()\fR, \fIsyswrite()\fR and \fItell()\fR
(see perlport for more details).  See the \f(CW$/\fR and \f(CW\*(C`$\e\*(C'\fR variables
in perlvar for how to manually set your input and output
line-termination sequences.
.IP "bless \s-1REF\s0,CLASSNAME" 8
.IX Xref "bless"
.IX Item "bless REF,CLASSNAME"
.PD 0
.IP "bless \s-1REF\s0" 8
.IX Item "bless REF"
.PD
This function tells the thingy referenced by \s-1REF\s0 that it is now an object
in the \s-1CLASSNAME\s0 package.  If \s-1CLASSNAME\s0 is omitted, the current package
is used.  Because a \f(CW\*(C`bless\*(C'\fR is often the last thing in a constructor,
it returns the reference for convenience.  Always use the two-argument
version if a derived class might inherit the function doing the blessing.
See perltoot and perlobj for more about the blessing (and blessings)
of objects.
.Sp
Consider always blessing objects in CLASSNAMEs that are mixed case.
Namespaces with all lowercase names are considered reserved for
Perl pragmata.  Builtin types have all uppercase names. To prevent
confusion, you may wish to avoid such package names as well.  Make sure
that \s-1CLASSNAME\s0 is a true value.
.Sp
See \*(L"Perl Modules\*(R" in perlmod.
.IP "caller \s-1EXPR\s0" 8
.IX Xref "caller call stack stack stack trace"
.IX Item "caller EXPR"
.PD 0
.IP "caller" 8
.IX Item "caller"
.PD
Returns the context of the current subroutine call.  In scalar context,
returns the caller's package name if there is a caller, that is, if
we're in a subroutine or \f(CW\*(C`eval\*(C'\fR or \f(CW\*(C`require\*(C'\fR, and the undefined value
otherwise.  In list context, returns
.Sp
.Vb 1
\&    ($package, $filename, $line) = caller;
.Ve
.Sp
With \s-1EXPR\s0, it returns some extra information that the debugger uses to
print a stack trace.  The value of \s-1EXPR\s0 indicates how many call frames
to go back before the current one.
.Sp
.Vb 2
\&    ($package, $filename, $line, $subroutine, $hasargs,
\&    $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller($i);
.Ve
.Sp
Here \f(CW$subroutine\fR may be \f(CW\*(C`(eval)\*(C'\fR if the frame is not a subroutine
call, but an \f(CW\*(C`eval\*(C'\fR.  In such a case additional elements \f(CW$evaltext\fR and
\&\f(CW$is_require\fR are set: \f(CW$is_require\fR is true if the frame is created by a
\&\f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR statement, \f(CW$evaltext\fR contains the text of the
\&\f(CW\*(C`eval EXPR\*(C'\fR statement.  In particular, for an \f(CW\*(C`eval BLOCK\*(C'\fR statement,
\&\f(CW$filename\fR is \f(CW\*(C`(eval)\*(C'\fR, but \f(CW$evaltext\fR is undefined.  (Note also that
each \f(CW\*(C`use\*(C'\fR statement creates a \f(CW\*(C`require\*(C'\fR frame inside an \f(CW\*(C`eval EXPR\*(C'\fR
frame.)  \f(CW$subroutine\fR may also be \f(CW\*(C`(unknown)\*(C'\fR if this particular
subroutine happens to have been deleted from the symbol table.
\&\f(CW$hasargs\fR is true if a new instance of \f(CW@_\fR was set up for the frame.
\&\f(CW$hints\fR and \f(CW$bitmask\fR contain pragmatic hints that the caller was
compiled with.  The \f(CW$hints\fR and \f(CW$bitmask\fR values are subject to change
between versions of Perl, and are not meant for external use.
.Sp
Furthermore, when called from within the \s-1DB\s0 package, caller returns more
detailed information: it sets the list variable \f(CW@DB::args\fR to be the
arguments with which the subroutine was invoked.
.Sp
Be aware that the optimizer might have optimized call frames away before
\&\f(CW\*(C`caller\*(C'\fR had a chance to get the information.  That means that \f(CWcaller(N)\fR
might not return information about the call frame you expect it do, for
\&\f(CW\*(C`N > 1\*(C'\fR.  In particular, \f(CW@DB::args\fR might have information from the
previous time \f(CW\*(C`caller\*(C'\fR was called.
.IP "chdir \s-1EXPR\s0" 8
.IX Xref "chdir cd"
.IX Item "chdir EXPR"
.PD 0
.IP "chdir \s-1FILEHANDLE\s0" 8
.IX Item "chdir FILEHANDLE"
.IP "chdir \s-1DIRHANDLE\s0" 8
.IX Item "chdir DIRHANDLE"
.IP "chdir" 8
.IX Item "chdir"
.PD
Changes the working directory to \s-1EXPR\s0, if possible. If \s-1EXPR\s0 is omitted,
changes to the directory specified by \f(CW$ENV{HOME}\fR, if set; if not,
changes to the directory specified by \f(CW$ENV{LOGDIR}\fR. (Under \s-1VMS\s0, the
variable \f(CW$ENV{SYS$LOGIN}\fR is also checked, and used if it is set.) If
neither is set, \f(CW\*(C`chdir\*(C'\fR does nothing. It returns true upon success,
false otherwise. See the example under \f(CW\*(C`die\*(C'\fR.
.Sp
On systems that support fchdir, you might pass a file handle or
directory handle as argument.  On systems that don't support fchdir,
passing handles produces a fatal error at run time.
.IP "chmod \s-1LIST\s0" 8
.IX Xref "chmod permission mode"
.IX Item "chmod LIST"
Changes the permissions of a list of files.  The first element of the
list must be the numerical mode, which should probably be an octal
number, and which definitely should \fInot\fR be a string of octal digits:
\&\f(CW0644\fR is okay, \f(CW'0644'\fR is not.  Returns the number of files
successfully changed.  See also \*(L"oct\*(R", if all you have is a string.
.Sp
.Vb 6
\&    $cnt = chmod 0755, 'foo', 'bar';
\&    chmod 0755, @executables;
\&    $mode = '0644'; chmod $mode, 'foo';      # !!! sets mode to
\&                                             # --w----r-T
\&    $mode = '0644'; chmod oct($mode), 'foo'; # this is better
\&    $mode = 0644;   chmod $mode, 'foo';      # this is best
.Ve
.Sp
On systems that support fchmod, you might pass file handles among the
files.  On systems that don't support fchmod, passing file handles
produces a fatal error at run time.
.Sp
.Vb 3
\&    open(my $fh, "<", "foo");
\&    my $perm = (stat $fh)[2] & 07777;
\&    chmod($perm | 0600, $fh);
.Ve
.Sp
You can also import the symbolic \f(CW\*(C`S_I*\*(C'\fR constants from the Fcntl
module:
.Sp
.Vb 1
\&    use Fcntl ':mode';
.Ve
.Sp
.Vb 2
\&    chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;
\&    # This is identical to the chmod 0755 of the above example.
.Ve
.IP "chomp \s-1VARIABLE\s0" 8
.IX Xref "chomp INPUT_RECORD_SEPARATOR $ newline eol"
.IX Item "chomp VARIABLE"
.PD 0
.IP "chomp( \s-1LIST\s0 )" 8
.IX Item "chomp( LIST )"
.IP "chomp" 8
.IX Item "chomp"
.PD
This safer version of \*(L"chop\*(R" removes any trailing string
that corresponds to the current value of \f(CW$/\fR (also known as
\&\f(CW$INPUT_RECORD_SEPARATOR\fR in the \f(CW\*(C`English\*(C'\fR module).  It returns the total
number of characters removed from all its arguments.  It's often used to
remove the newline from the end of an input record when you're worried
that the final record may be missing its newline.  When in paragraph
mode (\f(CW\*(C`$/ = ""\*(C'\fR), it removes all trailing newlines from the string.
When in slurp mode (\f(CW\*(C`$/ = undef\*(C'\fR) or fixed-length record mode (\f(CW$/\fR is
a reference to an integer or the like, see perlvar) \fIchomp()\fR won't
remove anything.
If \s-1VARIABLE\s0 is omitted, it chomps \f(CW$_\fR.  Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chomp;  # avoid \en on last field
\&        @array = split(/:/);
\&        # ...
\&    }
.Ve
.Sp
If \s-1VARIABLE\s0 is a hash, it chomps the hash's values, but not its keys.
.Sp
You can actually chomp anything that's an lvalue, including an assignment:
.Sp
.Vb 2
\&    chomp($cwd = `pwd`);
\&    chomp($answer = <STDIN>);
.Ve
.Sp
If you chomp a list, each element is chomped, and the total number of
characters removed is returned.
.Sp
If the \f(CW\*(C`encoding\*(C'\fR pragma is in scope then the lengths returned are
calculated from the length of \f(CW$/\fR in Unicode characters, which is not
always the same as the length of \f(CW$/\fR in the native encoding.
.Sp
Note that parentheses are necessary when you're chomping anything
that is not a simple variable.  This is because \f(CW\*(C`chomp $cwd = `pwd`;\*(C'\fR
is interpreted as \f(CW\*(C`(chomp $cwd) = `pwd`;\*(C'\fR, rather than as
\&\f(CW\*(C`chomp( $cwd = `pwd` )\*(C'\fR which you might expect.  Similarly,
\&\f(CW\*(C`chomp $a, $b\*(C'\fR is interpreted as \f(CW\*(C`chomp($a), $b\*(C'\fR rather than
as \f(CW\*(C`chomp($a, $b)\*(C'\fR.
.IP "chop \s-1VARIABLE\s0" 8
.IX Xref "chop"
.IX Item "chop VARIABLE"
.PD 0
.IP "chop( \s-1LIST\s0 )" 8
.IX Item "chop( LIST )"
.IP "chop" 8
.IX Item "chop"
.PD
Chops off the last character of a string and returns the character
chopped.  It is much more efficient than \f(CW\*(C`s/.$//s\*(C'\fR because it neither
scans nor copies the string.  If \s-1VARIABLE\s0 is omitted, chops \f(CW$_\fR.
If \s-1VARIABLE\s0 is a hash, it chops the hash's values, but not its keys.
.Sp
You can actually chop anything that's an lvalue, including an assignment.
.Sp
If you chop a list, each element is chopped.  Only the value of the
last \f(CW\*(C`chop\*(C'\fR is returned.
.Sp
Note that \f(CW\*(C`chop\*(C'\fR returns the last character.  To return all but the last
character, use \f(CW\*(C`substr($string, 0, \-1)\*(C'\fR.
.Sp
See also \*(L"chomp\*(R".
.IP "chown \s-1LIST\s0" 8
.IX Xref "chown owner user group"
.IX Item "chown LIST"
Changes the owner (and group) of a list of files.  The first two
elements of the list must be the \fInumeric\fR uid and gid, in that
order.  A value of \-1 in either position is interpreted by most
systems to leave that value unchanged.  Returns the number of files
successfully changed.
.Sp
.Vb 2
\&    $cnt = chown $uid, $gid, 'foo', 'bar';
\&    chown $uid, $gid, @filenames;
.Ve
.Sp
On systems that support fchown, you might pass file handles among the
files.  On systems that don't support fchown, passing file handles
produces a fatal error at run time.
.Sp
Here's an example that looks up nonnumeric uids in the passwd file:
.Sp
.Vb 4
\&    print "User: ";
\&    chomp($user = <STDIN>);
\&    print "Files: ";
\&    chomp($pattern = <STDIN>);
.Ve
.Sp
.Vb 2
\&    ($login,$pass,$uid,$gid) = getpwnam($user)
\&        or die "$user not in passwd file";
.Ve
.Sp
.Vb 2
\&    @ary = glob($pattern);      # expand filenames
\&    chown $uid, $gid, @ary;
.Ve
.Sp
On most systems, you are not allowed to change the ownership of the
file unless you're the superuser, although you should be able to change
the group to any of your secondary groups.  On insecure systems, these
restrictions may be relaxed, but this is not a portable assumption.
On \s-1POSIX\s0 systems, you can detect this condition this way:
.Sp
.Vb 2
\&    use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
\&    $can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);
.Ve
.IP "chr \s-1NUMBER\s0" 8
.IX Xref "chr character ASCII Unicode"
.IX Item "chr NUMBER"
.PD 0
.IP "chr" 8
.IX Item "chr"
.PD
Returns the character represented by that \s-1NUMBER\s0 in the character set.
For example, \f(CW\*(C`chr(65)\*(C'\fR is \f(CW"A"\fR in either \s-1ASCII\s0 or Unicode, and
chr(0x263a) is a Unicode smiley face.  Note that characters from 128
to 255 (inclusive) are by default not encoded in \s-1UTF\-8\s0 Unicode for
backward compatibility reasons (but see encoding).
.Sp
If \s-1NUMBER\s0 is omitted, uses \f(CW$_\fR.
.Sp
For the reverse, use \*(L"ord\*(R".
.Sp
Note that under the \f(CW\*(C`bytes\*(C'\fR pragma the \s-1NUMBER\s0 is masked to
the low eight bits.
.Sp
See perlunicode and encoding for more about Unicode.
.IP "chroot \s-1FILENAME\s0" 8
.IX Xref "chroot root"
.IX Item "chroot FILENAME"
.PD 0
.IP "chroot" 8
.IX Item "chroot"
.PD
This function works like the system call by the same name: it makes the
named directory the new root directory for all further pathnames that
begin with a \f(CW\*(C`/\*(C'\fR by your process and all its children.  (It doesn't
change your current working directory, which is unaffected.)  For security
reasons, this call is restricted to the superuser.  If \s-1FILENAME\s0 is
omitted, does a \f(CW\*(C`chroot\*(C'\fR to \f(CW$_\fR.
.IP "close \s-1FILEHANDLE\s0" 8
.IX Xref "close"
.IX Item "close FILEHANDLE"
.PD 0
.IP "close" 8
.IX Item "close"
.PD
Closes the file or pipe associated with the file handle, returning
true only if \s-1IO\s0 buffers are successfully flushed and closes the system
file descriptor.  Closes the currently selected filehandle if the
argument is omitted.
.Sp
You don't have to close \s-1FILEHANDLE\s0 if you are immediately going to do
another \f(CW\*(C`open\*(C'\fR on it, because \f(CW\*(C`open\*(C'\fR will close it for you.  (See
\&\f(CW\*(C`open\*(C'\fR.)  However, an explicit \f(CW\*(C`close\*(C'\fR on an input file resets the line
counter (\f(CW$.\fR), while the implicit close done by \f(CW\*(C`open\*(C'\fR does not.
.Sp
If the file handle came from a piped open, \f(CW\*(C`close\*(C'\fR will additionally
return false if one of the other system calls involved fails, or if the
program exits with non-zero status.  (If the only problem was that the
program exited non\-zero, \f(CW$!\fR will be set to \f(CW0\fR.)  Closing a pipe
also waits for the process executing on the pipe to complete, in case you
want to look at the output of the pipe afterwards, and
implicitly puts the exit status value of that command into \f(CW$?\fR.
.Sp
Prematurely closing the read end of a pipe (i.e. before the process
writing to it at the other end has closed it) will result in a
\&\s-1SIGPIPE\s0 being delivered to the writer.  If the other end can't
handle that, be sure to read all the data before closing the pipe.
.Sp
Example:
.Sp
.Vb 8
\&    open(OUTPUT, '|sort >foo')  # pipe to sort
\&        or die "Can't start sort: $!";
\&    #...                        # print stuff to output
\&    close OUTPUT                # wait for sort to finish
\&        or warn $! ? "Error closing sort pipe: $!"
\&                   : "Exit status $? from sort";
\&    open(INPUT, 'foo')          # get sort's results
\&        or die "Can't open 'foo' for input: $!";
.Ve
.Sp
\&\s-1FILEHANDLE\s0 may be an expression whose value can be used as an indirect
filehandle, usually the real filehandle name.
.IP "closedir \s-1DIRHANDLE\s0" 8
.IX Xref "closedir"
.IX Item "closedir DIRHANDLE"
Closes a directory opened by \f(CW\*(C`opendir\*(C'\fR and returns the success of that
system call.
.IP "connect \s-1SOCKET\s0,NAME" 8
.IX Xref "connect"
.IX Item "connect SOCKET,NAME"
Attempts to connect to a remote socket, just as the connect system call
does.  Returns true if it succeeded, false otherwise.  \s-1NAME\s0 should be a
packed address of the appropriate type for the socket.  See the examples in
\&\*(L"Sockets: Client/Server Communication\*(R" in perlipc.
.IP "continue \s-1BLOCK\s0" 8
.IX Xref "continue"
.IX Item "continue BLOCK"
\&\f(CW\*(C`continue\*(C'\fR is actually a flow control statement rather than a function.  If
there is a \f(CW\*(C`continue\*(C'\fR \s-1BLOCK\s0 attached to a \s-1BLOCK\s0 (typically in a \f(CW\*(C`while\*(C'\fR or
\&\f(CW\*(C`foreach\*(C'\fR), it is always executed just before the conditional is about to
be evaluated again, just like the third part of a \f(CW\*(C`for\*(C'\fR loop in C.  Thus
it can be used to increment a loop variable, even when the loop has been
continued via the \f(CW\*(C`next\*(C'\fR statement (which is similar to the C \f(CW\*(C`continue\*(C'\fR
statement).
.Sp
\&\f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR may appear within a \f(CW\*(C`continue\*(C'\fR
block.  \f(CW\*(C`last\*(C'\fR and \f(CW\*(C`redo\*(C'\fR will behave as if they had been executed within
the main block.  So will \f(CW\*(C`next\*(C'\fR, but since it will execute a \f(CW\*(C`continue\*(C'\fR
block, it may be more entertaining.
.Sp
.Vb 9
\&    while (EXPR) {
\&        ### redo always comes here
\&        do_something;
\&    } continue {
\&        ### next always comes here
\&        do_something_else;
\&        # then back the top to re-check EXPR
\&    }
\&    ### last always comes here
.Ve
.Sp
Omitting the \f(CW\*(C`continue\*(C'\fR section is semantically equivalent to using an
empty one, logically enough.  In that case, \f(CW\*(C`next\*(C'\fR goes directly back
to check the condition at the top of the loop.
.IP "cos \s-1EXPR\s0" 8
.IX Xref "cos cosine acos arccosine"
.IX Item "cos EXPR"
.PD 0
.IP "cos" 8
.IX Item "cos"
.PD
Returns the cosine of \s-1EXPR\s0 (expressed in radians).  If \s-1EXPR\s0 is omitted,
takes cosine of \f(CW$_\fR.
.Sp
For the inverse cosine operation, you may use the \f(CW\*(C`Math::Trig::acos()\*(C'\fR
function, or use this relation:
.Sp
.Vb 1
\&    sub acos { atan2( sqrt(1 - $_[0] * $_[0]), $_[0] ) }
.Ve
.IP "crypt \s-1PLAINTEXT\s0,SALT" 8
.IX Xref "crypt digest hash salt plaintext password decrypt cryptography passwd"
.IX Item "crypt PLAINTEXT,SALT"
Creates a digest string exactly like the \fIcrypt\fR\|(3) function in the C
library (assuming that you actually have a version there that has not
been extirpated as a potential munitions).
.Sp
\&\fIcrypt()\fR is a one-way hash function.  The \s-1PLAINTEXT\s0 and \s-1SALT\s0 is turned
into a short string, called a digest, which is returned.  The same
\&\s-1PLAINTEXT\s0 and \s-1SALT\s0 will always return the same string, but there is no
(known) way to get the original \s-1PLAINTEXT\s0 from the hash.  Small
changes in the \s-1PLAINTEXT\s0 or \s-1SALT\s0 will result in large changes in the
digest.
.Sp
There is no decrypt function.  This function isn't all that useful for
cryptography (for that, look for \fICrypt\fR modules on your nearby \s-1CPAN\s0
mirror) and the name \*(L"crypt\*(R" is a bit of a misnomer.  Instead it is
primarily used to check if two pieces of text are the same without
having to transmit or store the text itself.  An example is checking
if a correct password is given.  The digest of the password is stored,
not the password itself.  The user types in a password that is
\&\fIcrypt()\fR'd with the same salt as the stored digest.  If the two digests
match the password is correct.
.Sp
When verifying an existing digest string you should use the digest as
the salt (like \f(CW\*(C`crypt($plain, $digest) eq $digest\*(C'\fR).  The \s-1SALT\s0 used
to create the digest is visible as part of the digest.  This ensures
\&\fIcrypt()\fR will hash the new string with the same salt as the digest.
This allows your code to work with the standard crypt and
with more exotic implementations.  In other words, do not assume
anything about the returned string itself, or how many bytes in the
digest matter.
.Sp
Traditionally the result is a string of 13 bytes: two first bytes of
the salt, followed by 11 bytes from the set \f(CW\*(C`[./0\-9A\-Za\-z]\*(C'\fR, and only
the first eight bytes of the digest string mattered, but alternative
hashing schemes (like \s-1MD5\s0), higher level security schemes (like C2),
and implementations on non-UNIX platforms may produce different
strings.
.Sp
When choosing a new salt create a random two character string whose
characters come from the set \f(CW\*(C`[./0\-9A\-Za\-z]\*(C'\fR (like \f(CW\*(C`join '', ('.',
\&'/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]\*(C'\fR).  This set of
characters is just a recommendation; the characters allowed in
the salt depend solely on your system's crypt library, and Perl can't
restrict what salts \f(CW\*(C`crypt()\*(C'\fR accepts.
.Sp
Here's an example that makes sure that whoever runs this program knows
their password:
.Sp
.Vb 1
\&    $pwd = (getpwuid($<))[1];
.Ve
.Sp
.Vb 5
\&    system "stty -echo";
\&    print "Password: ";
\&    chomp($word = <STDIN>);
\&    print "\en";
\&    system "stty echo";
.Ve
.Sp
.Vb 5
\&    if (crypt($word, $pwd) ne $pwd) {
\&        die "Sorry...\en";
\&    } else {
\&        print "ok\en";
\&    }
.Ve
.Sp
Of course, typing in your own password to whoever asks you
for it is unwise.
.Sp
The crypt function is unsuitable for hashing large quantities
of data, not least of all because you can't get the information
back.  Look at the Digest module for more robust algorithms.
.Sp
If using \fIcrypt()\fR on a Unicode string (which \fIpotentially\fR has
characters with codepoints above 255), Perl tries to make sense
of the situation by trying to downgrade (a copy of the string)
the string back to an eight-bit byte string before calling \fIcrypt()\fR
(on that copy).  If that works, good.  If not, \fIcrypt()\fR dies with
\&\f(CW\*(C`Wide character in crypt\*(C'\fR.
.IP "dbmclose \s-1HASH\s0" 8
.IX Xref "dbmclose"
.IX Item "dbmclose HASH"
[This function has been largely superseded by the \f(CW\*(C`untie\*(C'\fR function.]
.Sp
Breaks the binding between a \s-1DBM\s0 file and a hash.
.IP "dbmopen \s-1HASH\s0,DBNAME,MASK" 8
.IX Xref "dbmopen dbm ndbm sdbm gdbm"
.IX Item "dbmopen HASH,DBNAME,MASK"
[This function has been largely superseded by the \f(CW\*(C`tie\*(C'\fR function.]
.Sp
This binds a \fIdbm\fR\|(3), \fIndbm\fR\|(3), \fIsdbm\fR\|(3), \fIgdbm\fR\|(3), or Berkeley \s-1DB\s0 file to a
hash.  \s-1HASH\s0 is the name of the hash.  (Unlike normal \f(CW\*(C`open\*(C'\fR, the first
argument is \fInot\fR a filehandle, even though it looks like one).  \s-1DBNAME\s0
is the name of the database (without the \fI.dir\fR or \fI.pag\fR extension if
any).  If the database does not exist, it is created with protection
specified by \s-1MASK\s0 (as modified by the \f(CW\*(C`umask\*(C'\fR).  If your system supports
only the older \s-1DBM\s0 functions, you may perform only one \f(CW\*(C`dbmopen\*(C'\fR in your
program.  In older versions of Perl, if your system had neither \s-1DBM\s0 nor
ndbm, calling \f(CW\*(C`dbmopen\*(C'\fR produced a fatal error; it now falls back to
\&\fIsdbm\fR\|(3).
.Sp
If you don't have write access to the \s-1DBM\s0 file, you can only read hash
variables, not set them.  If you want to test whether you can write,
either use file tests or try setting a dummy hash entry inside an \f(CW\*(C`eval\*(C'\fR,
which will trap the error.
.Sp
Note that functions such as \f(CW\*(C`keys\*(C'\fR and \f(CW\*(C`values\*(C'\fR may return huge lists
when used on large \s-1DBM\s0 files.  You may prefer to use the \f(CW\*(C`each\*(C'\fR
function to iterate over large \s-1DBM\s0 files.  Example:
.Sp
.Vb 6
\&    # print out history file offsets
\&    dbmopen(%HIST,'/usr/lib/news/history',0666);
\&    while (($key,$val) = each %HIST) {
\&        print $key, ' = ', unpack('L',$val), "\en";
\&    }
\&    dbmclose(%HIST);
.Ve
.Sp
See also AnyDBM_File for a more general description of the pros and
cons of the various dbm approaches, as well as DB_File for a particularly
rich implementation.
.Sp
You can control which \s-1DBM\s0 library you use by loading that library
before you call \fIdbmopen()\fR:
.Sp
.Vb 3
\&    use DB_File;
\&    dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
\&        or die "Can't open netscape history file: $!";
.Ve
.IP "defined \s-1EXPR\s0" 8
.IX Xref "defined undef undefined"
.IX Item "defined EXPR"
.PD 0
.IP "defined" 8
.IX Item "defined"
.PD
Returns a Boolean value telling whether \s-1EXPR\s0 has a value other than
the undefined value \f(CW\*(C`undef\*(C'\fR.  If \s-1EXPR\s0 is not present, \f(CW$_\fR will be
checked.
.Sp
Many operations return \f(CW\*(C`undef\*(C'\fR to indicate failure, end of file,
system error, uninitialized variable, and other exceptional
conditions.  This function allows you to distinguish \f(CW\*(C`undef\*(C'\fR from
other values.  (A simple Boolean test will not distinguish among
\&\f(CW\*(C`undef\*(C'\fR, zero, the empty string, and \f(CW"0"\fR, which are all equally
false.)  Note that since \f(CW\*(C`undef\*(C'\fR is a valid scalar, its presence
doesn't \fInecessarily\fR indicate an exceptional condition: \f(CW\*(C`pop\*(C'\fR
returns \f(CW\*(C`undef\*(C'\fR when its argument is an empty array, \fIor\fR when the
element to return happens to be \f(CW\*(C`undef\*(C'\fR.
.Sp
You may also use \f(CW\*(C`defined(&func)\*(C'\fR to check whether subroutine \f(CW&func\fR
has ever been defined.  The return value is unaffected by any forward
declarations of \f(CW&func\fR.  Note that a subroutine which is not defined
may still be callable: its package may have an \f(CW\*(C`AUTOLOAD\*(C'\fR method that
makes it spring into existence the first time that it is called \*(-- see
perlsub.
.Sp
Use of \f(CW\*(C`defined\*(C'\fR on aggregates (hashes and arrays) is deprecated.  It
used to report whether memory for that aggregate has ever been
allocated.  This behavior may disappear in future versions of Perl.
You should instead use a simple test for size:
.Sp
.Vb 2
\&    if (@an_array) { print "has array elements\en" }
\&    if (%a_hash)   { print "has hash members\en"   }
.Ve
.Sp
When used on a hash element, it tells you whether the value is defined,
not whether the key exists in the hash.  Use \*(L"exists\*(R" for the latter
purpose.
.Sp
Examples:
.Sp
.Vb 6
\&    print if defined $switch{'D'};
\&    print "$val\en" while defined($val = pop(@ary));
\&    die "Can't readlink $sym: $!"
\&        unless defined($value = readlink $sym);
\&    sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }
\&    $debugging = 0 unless defined $debugging;
.Ve
.Sp
Note:  Many folks tend to overuse \f(CW\*(C`defined\*(C'\fR, and then are surprised to
discover that the number \f(CW0\fR and \f(CW""\fR (the zero-length string) are, in fact,
defined values.  For example, if you say
.Sp
.Vb 1
\&    "ab" =~ /a(.*)b/;
.Ve
.Sp
The pattern match succeeds, and \f(CW$1\fR is defined, despite the fact that it
matched \*(L"nothing\*(R".  It didn't really fail to match anything.  Rather, it
matched something that happened to be zero characters long.  This is all
very above-board and honest.  When a function returns an undefined value,
it's an admission that it couldn't give you an honest answer.  So you
should use \f(CW\*(C`defined\*(C'\fR only when you're questioning the integrity of what
you're trying to do.  At other times, a simple comparison to \f(CW0\fR or \f(CW""\fR is
what you want.
.Sp
See also \*(L"undef\*(R", \*(L"exists\*(R", \*(L"ref\*(R".
.IP "delete \s-1EXPR\s0" 8
.IX Xref "delete"
.IX Item "delete EXPR"
Given an expression that specifies a hash element, array element, hash slice,
or array slice, deletes the specified element(s) from the hash or array.
In the case of an array, if the array elements happen to be at the end,
the size of the array will shrink to the highest element that tests
true for \fIexists()\fR (or 0 if no such element exists).
.Sp
Returns a list with the same number of elements as the number of elements
for which deletion was attempted.  Each element of that list consists of
either the value of the element deleted, or the undefined value.  In scalar
context, this means that you get the value of the last element deleted (or
the undefined value if that element did not exist).
.Sp
.Vb 4
\&    %hash = (foo => 11, bar => 22, baz => 33);
\&    $scalar = delete $hash{foo};             # $scalar is 11
\&    $scalar = delete @hash{qw(foo bar)};     # $scalar is 22
\&    @array  = delete @hash{qw(foo bar baz)}; # @array  is (undef,undef,33)
.Ve
.Sp
Deleting from \f(CW%ENV\fR modifies the environment.  Deleting from
a hash tied to a \s-1DBM\s0 file deletes the entry from the \s-1DBM\s0 file.  Deleting
from a \f(CW\*(C`tie\*(C'\fRd hash or array may not necessarily return anything.
.Sp
Deleting an array element effectively returns that position of the array
to its initial, uninitialized state.  Subsequently testing for the same
element with \fIexists()\fR will return false.  Also, deleting array elements
in the middle of an array will not shift the index of the elements
after them down.  Use \fIsplice()\fR for that.  See \*(L"exists\*(R".
.Sp
The following (inefficiently) deletes all the values of \f(CW%HASH\fR and \f(CW@ARRAY:\fR
.Sp
.Vb 3
\&    foreach $key (keys %HASH) {
\&        delete $HASH{$key};
\&    }
.Ve
.Sp
.Vb 3
\&    foreach $index (0 .. $#ARRAY) {
\&        delete $ARRAY[$index];
\&    }
.Ve
.Sp
And so do these:
.Sp
.Vb 1
\&    delete @HASH{keys %HASH};
.Ve
.Sp
.Vb 1
\&    delete @ARRAY[0 .. $#ARRAY];
.Ve
.Sp
But both of these are slower than just assigning the empty list
or undefining \f(CW%HASH\fR or \f(CW@ARRAY:\fR
.Sp
.Vb 2
\&    %HASH = ();         # completely empty %HASH
\&    undef %HASH;        # forget %HASH ever existed
.Ve
.Sp
.Vb 2
\&    @ARRAY = ();        # completely empty @ARRAY
\&    undef @ARRAY;       # forget @ARRAY ever existed
.Ve
.Sp
Note that the \s-1EXPR\s0 can be arbitrarily complicated as long as the final
operation is a hash element, array element,  hash slice, or array slice
lookup:
.Sp
.Vb 2
\&    delete $ref->[$x][$y]{$key};
\&    delete @{$ref->[$x][$y]}{$key1, $key2, @morekeys};
.Ve
.Sp
.Vb 2
\&    delete $ref->[$x][$y][$index];
\&    delete @{$ref->[$x][$y]}[$index1, $index2, @moreindices];
.Ve
.IP "die \s-1LIST\s0" 8
.IX Xref "die throw exception raise $@ abort"
.IX Item "die LIST"
Outside an \f(CW\*(C`eval\*(C'\fR, prints the value of \s-1LIST\s0 to \f(CW\*(C`STDERR\*(C'\fR and
exits with the current value of \f(CW$!\fR (errno).  If \f(CW$!\fR is \f(CW0\fR,
exits with the value of \f(CW\*(C`($? >> 8)\*(C'\fR (backtick `command`
status).  If \f(CW\*(C`($? >> 8)\*(C'\fR is \f(CW0\fR, exits with \f(CW255\fR.  Inside
an \f(CW\*(C`eval(),\*(C'\fR the error message is stuffed into \f(CW$@\fR and the
\&\f(CW\*(C`eval\*(C'\fR is terminated with the undefined value.  This makes
\&\f(CW\*(C`die\*(C'\fR the way to raise an exception.
.Sp
Equivalent examples:
.Sp
.Vb 2
\&    die "Can't cd to spool: $!\en" unless chdir '/usr/spool/news';
\&    chdir '/usr/spool/news' or die "Can't cd to spool: $!\en"
.Ve
.Sp
If the last element of \s-1LIST\s0 does not end in a newline, the current
script line number and input line number (if any) are also printed,
and a newline is supplied.  Note that the \*(L"input line number\*(R" (also
known as \*(L"chunk\*(R") is subject to whatever notion of \*(L"line\*(R" happens to
be currently in effect, and is also available as the special variable
\&\f(CW$.\fR.  See \*(L"$/\*(R" in perlvar and \*(L"$.\*(R" in perlvar.
.Sp
Hint: sometimes appending \f(CW", stopped"\fR to your message will cause it
to make better sense when the string \f(CW"at foo line 123"\fR is appended.
Suppose you are running script \*(L"canasta\*(R".
.Sp
.Vb 2
\&    die "/etc/games is no good";
\&    die "/etc/games is no good, stopped";
.Ve
.Sp
produce, respectively
.Sp
.Vb 2
\&    /etc/games is no good at canasta line 123.
\&    /etc/games is no good, stopped at canasta line 123.
.Ve
.Sp
See also \fIexit()\fR, \fIwarn()\fR, and the Carp module.
.Sp
If \s-1LIST\s0 is empty and \f(CW$@\fR already contains a value (typically from a
previous eval) that value is reused after appending \f(CW"\et...propagated"\fR.
This is useful for propagating exceptions:
.Sp
.Vb 2
\&    eval { ... };
\&    die unless $@ =~ /Expected exception/;
.Ve
.Sp
If \s-1LIST\s0 is empty and \f(CW$@\fR contains an object reference that has a
\&\f(CW\*(C`PROPAGATE\*(C'\fR method, that method will be called with additional file
and line number parameters.  The return value replaces the value in
\&\f(CW$@\fR.  i.e. as if \f(CW\*(C`$@ = eval { $@\->PROPAGATE(_\|_FILE_\|_, _\|_LINE_\|_) };\*(C'\fR
were called.
.Sp
If \f(CW$@\fR is empty then the string \f(CW"Died"\fR is used.
.Sp
\&\fIdie()\fR can also be called with a reference argument.  If this happens to be
trapped within an \fIeval()\fR, $@ contains the reference.  This behavior permits
a more elaborate exception handling implementation using objects that
maintain arbitrary state about the nature of the exception.  Such a scheme
is sometimes preferable to matching particular string values of $@ using
regular expressions.  Here's an example:
.Sp
.Vb 1
\&    use Scalar::Util 'blessed';
.Ve
.Sp
.Vb 9
\&    eval { ... ; die Some::Module::Exception->new( FOO => "bar" ) };
\&    if ($@) {
\&        if (blessed($@) && $@->isa("Some::Module::Exception")) {
\&            # handle Some::Module::Exception
\&        }
\&        else {
\&            # handle all other possible exceptions
\&        }
\&    }
.Ve
.Sp
Because perl will stringify uncaught exception messages before displaying
them, you may want to overload stringification operations on such custom
exception objects.  See overload for details about that.
.Sp
You can arrange for a callback to be run just before the \f(CW\*(C`die\*(C'\fR
does its deed, by setting the \f(CW$SIG{_\|_DIE_\|_}\fR hook.  The associated
handler will be called with the error text and can change the error
message, if it sees fit, by calling \f(CW\*(C`die\*(C'\fR again.  See
\&\*(L"$SIG{expr}\*(R" in perlvar for details on setting \f(CW%SIG\fR entries, and
\&\*(L"eval \s-1BLOCK\s0\*(R" for some examples.  Although this feature was 
to be run only right before your program was to exit, this is not
currently the case\*(--the \f(CW$SIG{_\|_DIE_\|_}\fR hook is currently called
even inside \fIeval()\fRed blocks/strings!  If one wants the hook to do
nothing in such situations, put
.Sp
.Vb 1
\&        die @_ if $^S;
.Ve
.Sp
as the first line of the handler (see \*(L"$^S\*(R" in perlvar).  Because
this promotes strange action at a distance, this counterintuitive
behavior may be fixed in a future release.
.IP "do \s-1BLOCK\s0" 8
.IX Xref "do block"
.IX Item "do BLOCK"
Not really a function.  Returns the value of the last command in the
sequence of commands indicated by \s-1BLOCK\s0.  When modified by the \f(CW\*(C`while\*(C'\fR or
\&\f(CW\*(C`until\*(C'\fR loop modifier, executes the \s-1BLOCK\s0 once before testing the loop
condition. (On other statements the loop modifiers test the conditional
first.)
.Sp
\&\f(CW\*(C`do BLOCK\*(C'\fR does \fInot\fR count as a loop, so the loop control statements
\&\f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR cannot be used to leave or restart the block.
See perlsyn for alternative strategies.
.IP "do \s-1SUBROUTINE\s0(\s-1LIST\s0)" 8
.IX Xref "do"
.IX Item "do SUBROUTINE(LIST)"
This form of subroutine call is deprecated.  See perlsub.
.IP "do \s-1EXPR\s0" 8
.IX Xref "do"
.IX Item "do EXPR"
Uses the value of \s-1EXPR\s0 as a filename and executes the contents of the
file as a Perl script.
.Sp
.Vb 1
\&    do 'stat.pl';
.Ve
.Sp
is just like
.Sp
.Vb 1
\&    eval `cat stat.pl`;
.Ve
.Sp
except that it's more efficient and concise, keeps track of the current
filename for error messages, searches the \f(CW@INC\fR directories, and updates
\&\f(CW%INC\fR if the file is found.  See \*(L"Predefined Names\*(R" in perlvar for these
variables.  It also differs in that code evaluated with \f(CW\*(C`do FILENAME\*(C'\fR
cannot see lexicals in the enclosing scope; \f(CW\*(C`eval STRING\*(C'\fR does.  It's the
same, however, in that it does reparse the file every time you call it,
so you probably don't want to do this inside a loop.
.Sp
If \f(CW\*(C`do\*(C'\fR cannot read the file, it returns undef and sets \f(CW$!\fR to the
error.  If \f(CW\*(C`do\*(C'\fR can read the file but cannot compile it, it
returns undef and sets an error message in \f(CW$@\fR.   If the file is
successfully compiled, \f(CW\*(C`do\*(C'\fR returns the value of the last expression
evaluated.
.Sp
Note that inclusion of library modules is better done with the
\&\f(CW\*(C`use\*(C'\fR and \f(CW\*(C`require\*(C'\fR operators, which also do automatic error checking
and raise an exception if there's a problem.
.Sp
You might like to use \f(CW\*(C`do\*(C'\fR to read in a program configuration
file.  Manual error checking can be done this way:
.Sp
.Vb 10
\&    # read in config files: system first, then user
\&    for $file ("/share/prog/defaults.rc",
\&               "$ENV{HOME}/.someprogrc")
\&   {
\&        unless ($return = do $file) {
\&            warn "couldn't parse $file: $@" if $@;
\&            warn "couldn't do $file: $!"    unless defined $return;
\&            warn "couldn't run $file"       unless $return;
\&        }
\&    }
.Ve
.IP "dump \s-1LABEL\s0" 8
.IX Xref "dump core undump"
.IX Item "dump LABEL"
.PD 0
.IP "dump" 8
.IX Item "dump"
.PD
This function causes an immediate core dump.  See also the \fB\-u\fR
command-line switch in perlrun, which does the same thing.
Primarily this is so that you can use the \fBundump\fR program (not
supplied) to turn your core dump into an executable binary after
having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing
a \f(CW\*(C`goto LABEL\*(C'\fR (with all the restrictions that \f(CW\*(C`goto\*(C'\fR suffers).
Think of it as a goto with an intervening core dump and reincarnation.
If \f(CW\*(C`LABEL\*(C'\fR is omitted, restarts the program from the top.
.Sp
\&\fB\s-1WARNING\s0\fR: Any files opened at the time of the dump will \fInot\fR
be open any more when the program is reincarnated, with possible
resulting confusion on the part of Perl.
.Sp
This function is now largely obsolete, partly because it's very
hard to convert a core file into an executable, and because the
real compiler backends for generating portable bytecode and compilable
C code have superseded it.  That's why you should now invoke it as
\&\f(CW\*(C`CORE::dump()\*(C'\fR, if you don't want to be warned against a possible
typo.
.Sp
If you're looking to use dump to speed up your program, consider
generating bytecode or native C code as described in perlcc.  If
you're just trying to accelerate a \s-1CGI\s0 script, consider using the
\&\f(CW\*(C`mod_perl\*(C'\fR extension to \fBApache\fR, or the \s-1CPAN\s0 module, CGI::Fast.
You might also consider autoloading or selfloading, which at least
make your program \fIappear\fR to run faster.
.IP "each \s-1HASH\s0" 8
.IX Xref "each hash, iterator"
.IX Item "each HASH"
When called in list context, returns a 2\-element list consisting of the
key and value for the next element of a hash, so that you can iterate over
it.  When called in scalar context, returns only the key for the next
element in the hash.
.Sp
Entries are returned in an apparently random order.  The actual random
order is subject to change in future versions of perl, but it is
guaranteed to be in the same order as either the \f(CW\*(C`keys\*(C'\fR or \f(CW\*(C`values\*(C'\fR
function would produce on the same (unmodified) hash.  Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec).
.Sp
When the hash is entirely read, a null array is returned in list context
(which when assigned produces a false (\f(CW0\fR) value), and \f(CW\*(C`undef\*(C'\fR in
scalar context.  The next call to \f(CW\*(C`each\*(C'\fR after that will start iterating
again.  There is a single iterator for each hash, shared by all \f(CW\*(C`each\*(C'\fR,
\&\f(CW\*(C`keys\*(C'\fR, and \f(CW\*(C`values\*(C'\fR function calls in the program; it can be reset by
reading all the elements from the hash, or by evaluating \f(CW\*(C`keys HASH\*(C'\fR or
\&\f(CW\*(C`values HASH\*(C'\fR.  If you add or delete elements of a hash while you're
iterating over it, you may get entries skipped or duplicated, so
don't.  Exception: It is always safe to delete the item most recently
returned by \f(CW\*(C`each()\*(C'\fR, which means that the following code will work:
.Sp
.Vb 4
\&        while (($key, $value) = each %hash) {
\&          print $key, "\en";
\&          delete $hash{$key};   # This is safe
\&        }
.Ve
.Sp
The following prints out your environment like the \fIprintenv\fR\|(1) program,
only in a different order:
.Sp
.Vb 3
\&    while (($key,$value) = each %ENV) {
\&        print "$key=$value\en";
\&    }
.Ve
.Sp
See also \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR and \f(CW\*(C`sort\*(C'\fR.
.IP "eof \s-1FILEHANDLE\s0" 8
.IX Xref "eof end of file end-of-file"
.IX Item "eof FILEHANDLE"
.PD 0
.IP "eof ()" 8
.IX Item "eof ()"
.IP "eof" 8
.IX Item "eof"
.PD
Returns 1 if the next read on \s-1FILEHANDLE\s0 will return end of file, or if
\&\s-1FILEHANDLE\s0 is not open.  \s-1FILEHANDLE\s0 may be an expression whose value
gives the real filehandle.  (Note that this function actually
reads a character and then \f(CW\*(C`ungetc\*(C'\fRs it, so isn't very useful in an
interactive context.)  Do not read from a terminal file (or call
\&\f(CW\*(C`eof(FILEHANDLE)\*(C'\fR on it) after end-of-file is reached.  File types such
as terminals may lose the end-of-file condition if you do.
.Sp
An \f(CW\*(C`eof\*(C'\fR without an argument uses the last file read.  Using \f(CW\*(C`eof()\*(C'\fR
with empty parentheses is very different.  It refers to the pseudo file
formed from the files listed on the command line and accessed via the
\&\f(CW\*(C`<>\*(C'\fR operator.  Since \f(CW\*(C`<>\*(C'\fR isn't explicitly opened,
as a normal filehandle is, an \f(CW\*(C`eof()\*(C'\fR before \f(CW\*(C`<>\*(C'\fR has been
used will cause \f(CW@ARGV\fR to be examined to determine if input is
available.   Similarly, an \f(CW\*(C`eof()\*(C'\fR after \f(CW\*(C`<>\*(C'\fR has returned
end-of-file will assume you are processing another \f(CW@ARGV\fR list,
and if you haven't set \f(CW@ARGV\fR, will read input from \f(CW\*(C`STDIN\*(C'\fR;
see \*(L"I/O Operators\*(R" in perlop.
.Sp
In a \f(CW\*(C`while (<>)\*(C'\fR loop, \f(CW\*(C`eof\*(C'\fR or \f(CW\*(C`eof(ARGV)\*(C'\fR can be used to
detect the end of each file, \f(CW\*(C`eof()\*(C'\fR will only detect the end of the
last file.  Examples:
.Sp
.Vb 7
\&    # reset line numbering on each input file
\&    while (<>) {
\&        next if /^\es*#/;        # skip comments
\&        print "$.\et$_";
\&    } continue {
\&        close ARGV  if eof;     # Not eof()!
\&    }
.Ve
.Sp
.Vb 8
\&    # insert dashes just before last line of last file
\&    while (<>) {
\&        if (eof()) {            # check for end of last file
\&            print "--------------\en";
\&        }
\&        print;
\&        last if eof();          # needed if we're reading from a terminal
\&    }
.Ve
.Sp
Practical hint: you almost never need to use \f(CW\*(C`eof\*(C'\fR in Perl, because the
input operators typically return \f(CW\*(C`undef\*(C'\fR when they run out of data, or if
there was an error.
.IP "eval \s-1EXPR\s0" 8
.IX Xref "eval try catch evaluate parse execute"
.IX Item "eval EXPR"
.PD 0
.IP "eval \s-1BLOCK\s0" 8
.IX Item "eval BLOCK"
.IP "eval" 8
.IX Item "eval"
.PD
In the first form, the return value of \s-1EXPR\s0 is parsed and executed as if it
were a little Perl program.  The value of the expression (which is itself
determined within scalar context) is first parsed, and if there weren't any
errors, executed in the lexical context of the current Perl program, so
that any variable settings or subroutine and format definitions remain
afterwards.  Note that the value is parsed every time the \f(CW\*(C`eval\*(C'\fR executes.
If \s-1EXPR\s0 is omitted, evaluates \f(CW$_\fR.  This form is typically used to
delay parsing and subsequent execution of the text of \s-1EXPR\s0 until run time.
.Sp
In the second form, the code within the \s-1BLOCK\s0 is parsed only once\*(--at the
same time the code surrounding the \f(CW\*(C`eval\*(C'\fR itself was parsed\*(--and executed
within the context of the current Perl program.  This form is typically
used to trap exceptions more efficiently than the first (see below), while
also providing the benefit of checking the code within \s-1BLOCK\s0 at compile
time.
.Sp
The final semicolon, if any, may be omitted from the value of \s-1EXPR\s0 or within
the \s-1BLOCK\s0.
.Sp
In both forms, the value returned is the value of the last expression
evaluated inside the mini\-program; a return statement may be also used, just
as with subroutines.  The expression providing the return value is evaluated
in void, scalar, or list context, depending on the context of the \f(CW\*(C`eval\*(C'\fR 
itself.  See \*(L"wantarray\*(R" for more on how the evaluation context can be 
determined.
.Sp
If there is a syntax error or runtime error, or a \f(CW\*(C`die\*(C'\fR statement is
executed, an undefined value is returned by \f(CW\*(C`eval\*(C'\fR, and \f(CW$@\fR is set to the
error message.  If there was no error, \f(CW$@\fR is guaranteed to be a null
string.  Beware that using \f(CW\*(C`eval\*(C'\fR neither silences perl from printing
warnings to \s-1STDERR\s0, nor does it stuff the text of warning messages into \f(CW$@\fR.
To do either of those, you have to use the \f(CW$SIG{_\|_WARN_\|_}\fR facility, or
turn off warnings inside the \s-1BLOCK\s0 or \s-1EXPR\s0 using \f(CW\*(C`no\ warnings\ 'all'\*(C'\fR.
See \*(L"warn\*(R", perlvar, warnings and perllexwarn.
.Sp
Note that, because \f(CW\*(C`eval\*(C'\fR traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as \f(CW\*(C`socket\*(C'\fR or \f(CW\*(C`symlink\*(C'\fR)
is implemented.  It is also Perl's exception trapping mechanism, where
the die operator is used to raise exceptions.
.Sp
If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in \f(CW$@\fR.
Examples:
.Sp
.Vb 2
\&    # make divide-by-zero nonfatal
\&    eval { $answer = $a / $b; }; warn $@ if $@;
.Ve
.Sp
.Vb 2
\&    # same thing, but less efficient
\&    eval '$answer = $a / $b'; warn $@ if $@;
.Ve
.Sp
.Vb 2
\&    # a compile-time error
\&    eval { $answer = };                 # WRONG
.Ve
.Sp
.Vb 2
\&    # a run-time error
\&    eval '$answer =';   # sets $@
.Ve
.Sp
Using the \f(CW\*(C`eval{}\*(C'\fR form as an exception trap in libraries does have some
issues.  Due to the current arguably broken state of \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hooks, you
may wish not to trigger any \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hooks that user code may have installed.
You can use the \f(CW\*(C`local $SIG{_\|_DIE_\|_}\*(C'\fR construct for this purpose,
as shown in this example:
.Sp
.Vb 3
\&    # a very private exception trap for divide-by-zero
\&    eval { local $SIG{'__DIE__'}; $answer = $a / $b; };
\&    warn $@ if $@;
.Ve
.Sp
This is especially significant, given that \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hooks can call
\&\f(CW\*(C`die\*(C'\fR again, which has the effect of changing their error messages:
.Sp
.Vb 7
\&    # __DIE__ hooks may modify error messages
\&    {
\&       local $SIG{'__DIE__'} =
\&              sub { (my $x = $_[0]) =~ s/foo/bar/g; die $x };
\&       eval { die "foo lives here" };
\&       print $@ if $@;                # prints "bar lives here"
\&    }
.Ve
.Sp
Because this promotes action at a distance, this counterintuitive behavior
may be fixed in a future release.
.Sp
With an \f(CW\*(C`eval\*(C'\fR, you should be especially careful to remember what's
being looked at when:
.Sp
.Vb 2
\&    eval $x;            # CASE 1
\&    eval "$x";          # CASE 2
.Ve
.Sp
.Vb 2
\&    eval '$x';          # CASE 3
\&    eval { $x };        # CASE 4
.Ve
.Sp
.Vb 2
\&    eval "\e$$x++";      # CASE 5
\&    $$x++;              # CASE 6
.Ve
.Sp
Cases 1 and 2 above behave identically: they run the code contained in
the variable \f(CW$x\fR.  (Although case 2 has misleading double quotes making
the reader wonder what else might be happening (nothing is).)  Cases 3
and 4 likewise behave in the same way: they run the code \f(CW'$x'\fR, which
does nothing but return the value of \f(CW$x\fR.  (Case 4 is preferred for
purely visual reasons, but it also has the advantage of compiling at
compile-time instead of at run\-time.)  Case 5 is a place where
normally you \fIwould\fR like to use double quotes, except that in this
particular situation, you can just use symbolic references instead, as
in case 6.
.Sp
\&\f(CW\*(C`eval BLOCK\*(C'\fR does \fInot\fR count as a loop, so the loop control statements
\&\f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR cannot be used to leave or restart the block.
.Sp
Note that as a very special case, an \f(CW\*(C`eval ''\*(C'\fR executed within the \f(CW\*(C`DB\*(C'\fR
package doesn't see the usual surrounding lexical scope, but rather the
scope of the first non-DB piece of code that called it. You don't normally
need to worry about this unless you are writing a Perl debugger.
.IP "exec \s-1LIST\s0" 8
.IX Xref "exec execute"
.IX Item "exec LIST"
.PD 0
.IP "exec \s-1PROGRAM\s0 \s-1LIST\s0" 8
.IX Item "exec PROGRAM LIST"
.PD
The \f(CW\*(C`exec\*(C'\fR function executes a system command \fIand never returns\fR\-\-
use \f(CW\*(C`system\*(C'\fR instead of \f(CW\*(C`exec\*(C'\fR if you want it to return.  It fails and
returns false only if the command does not exist \fIand\fR it is executed
directly instead of via your system's command shell (see below).
.Sp
Since it's a common mistake to use \f(CW\*(C`exec\*(C'\fR instead of \f(CW\*(C`system\*(C'\fR, Perl
warns you if there is a following statement which isn't \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`warn\*(C'\fR,
or \f(CW\*(C`exit\*(C'\fR (if \f(CW\*(C`\-w\*(C'\fR is set  \-  but you always do that).   If you
\&\fIreally\fR want to follow an \f(CW\*(C`exec\*(C'\fR with some other statement, you
can use one of these styles to avoid the warning:
.Sp
.Vb 2
\&    exec ('foo')   or print STDERR "couldn't exec foo: $!";
\&    { exec ('foo') }; print STDERR "couldn't exec foo: $!";
.Ve
.Sp
If there is more than one argument in \s-1LIST\s0, or if \s-1LIST\s0 is an array
with more than one value, calls \fIexecvp\fR\|(3) with the arguments in \s-1LIST\s0.
If there is only one scalar argument or an array with one element in it,
the argument is checked for shell metacharacters, and if there are any,
the entire argument is passed to the system's command shell for parsing
(this is \f(CW\*(C`/bin/sh \-c\*(C'\fR on Unix platforms, but varies on other platforms).
If there are no shell metacharacters in the argument, it is split into
words and passed directly to \f(CW\*(C`execvp\*(C'\fR, which is more efficient.
Examples:
.Sp
.Vb 2
\&    exec '/bin/echo', 'Your arguments are: ', @ARGV;
\&    exec "sort $outfile | uniq";
.Ve
.Sp
If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an \*(L"indirect object\*(R" (without a
comma) in front of the \s-1LIST\s0.  (This always forces interpretation of the
\&\s-1LIST\s0 as a multivalued list, even if there is only a single scalar in
the list.)  Example:
.Sp
.Vb 2
\&    $shell = '/bin/csh';
\&    exec $shell '-sh';          # pretend it's a login shell
.Ve
.Sp
or, more directly,
.Sp
.Vb 1
\&    exec {'/bin/csh'} '-sh';    # pretend it's a login shell
.Ve
.Sp
When the arguments get executed via the system shell, results will
be subject to its quirks and capabilities.  See \*(L"`STRING`\*(R" in perlop
for details.
.Sp
Using an indirect object with \f(CW\*(C`exec\*(C'\fR or \f(CW\*(C`system\*(C'\fR is also more
secure.  This usage (which also works fine with \fIsystem()\fR) forces
interpretation of the arguments as a multivalued list, even if the
list had just one argument.  That way you're safe from the shell
expanding wildcards or splitting up words with whitespace in them.
.Sp
.Vb 1
\&    @args = ( "echo surprise" );
.Ve
.Sp
.Vb 3
\&    exec @args;               # subject to shell escapes
\&                                # if @args == 1
\&    exec { $args[0] } @args;  # safe even with one-arg list
.Ve
.Sp
The first version, the one without the indirect object, ran the \fIecho\fR
program, passing it \f(CW"surprise"\fR an argument.  The second version
didn't\*(--it tried to run a program literally called \fI\*(L"echo surprise\*(R"\fR,
didn't find it, and set \f(CW$?\fR to a non-zero value indicating failure.
.Sp
Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before the exec, but this may not be supported on some platforms
(see perlport).  To be safe, you may need to set \f(CW$|\fR ($AUTOFLUSH
in English) or call the \f(CW\*(C`autoflush()\*(C'\fR method of \f(CW\*(C`IO::Handle\*(C'\fR on any
open handles in order to avoid lost output.
.Sp
Note that \f(CW\*(C`exec\*(C'\fR will not call your \f(CW\*(C`END\*(C'\fR blocks, nor will it call
any \f(CW\*(C`DESTROY\*(C'\fR methods in your objects.
.IP "exists \s-1EXPR\s0" 8
.IX Xref "exists autovivification"
.IX Item "exists EXPR"
Given an expression that specifies a hash element or array element,
returns true if the specified element in the hash or array has ever
been initialized, even if the corresponding value is undefined.  The
element is not autovivified if it doesn't exist.
.Sp
.Vb 3
\&    print "Exists\en"    if exists $hash{$key};
\&    print "Defined\en"   if defined $hash{$key};
\&    print "True\en"      if $hash{$key};
.Ve
.Sp
.Vb 3
\&    print "Exists\en"    if exists $array[$index];
\&    print "Defined\en"   if defined $array[$index];
\&    print "True\en"      if $array[$index];
.Ve
.Sp
A hash or array element can be true only if it's defined, and defined if
it exists, but the reverse doesn't necessarily hold true.
.Sp
Given an expression that specifies the name of a subroutine,
returns true if the specified subroutine has ever been declared, even
if it is undefined.  Mentioning a subroutine name for exists or defined
does not count as declaring it.  Note that a subroutine which does not
exist may still be callable: its package may have an \f(CW\*(C`AUTOLOAD\*(C'\fR
method that makes it spring into existence the first time that it is
called \*(-- see perlsub.
.Sp
.Vb 2
\&    print "Exists\en"    if exists &subroutine;
\&    print "Defined\en"   if defined &subroutine;
.Ve
.Sp
Note that the \s-1EXPR\s0 can be arbitrarily complicated as long as the final
operation is a hash or array key lookup or subroutine name:
.Sp
.Vb 2
\&    if (exists $ref->{A}->{B}->{$key})  { }
\&    if (exists $hash{A}{B}{$key})       { }
.Ve
.Sp
.Vb 2
\&    if (exists $ref->{A}->{B}->[$ix])   { }
\&    if (exists $hash{A}{B}[$ix])        { }
.Ve
.Sp
.Vb 1
\&    if (exists &{$ref->{A}{B}{$key}})   { }
.Ve
.Sp
Although the deepest nested array or hash will not spring into existence
just because its existence was tested, any intervening ones will.
Thus \f(CW\*(C`$ref\->{"A"}\*(C'\fR and \f(CW\*(C`$ref\->{"A"}\->{"B"}\*(C'\fR will spring
into existence due to the existence test for the \f(CW$key\fR element above.
This happens anywhere the arrow operator is used, including even:
.Sp
.Vb 3
\&    undef $ref;
\&    if (exists $ref->{"Some key"})      { }
\&    print $ref;             # prints HASH(0x80d3d5c)
.Ve
.Sp
This surprising autovivification in what does not at first\*(--or even
second\*(--glance appear to be an lvalue context may be fixed in a future
release.
.Sp
See \*(L"Pseudo\-hashes: Using an array as a hash\*(R" in perlref for specifics
on how \fIexists()\fR acts when used on a pseudo\-hash.
.Sp
Use of a subroutine call, rather than a subroutine name, as an argument
to \fIexists()\fR is an error.
.Sp
.Vb 2
\&    exists &sub;        # OK
\&    exists &sub();      # Error
.Ve
.IP "exit \s-1EXPR\s0" 8
.IX Xref "exit terminate abort"
.IX Item "exit EXPR"
.PD 0
.IP "exit" 8
.IX Item "exit"
.PD
Evaluates \s-1EXPR\s0 and exits immediately with that value.    Example:
.Sp
.Vb 2
\&    $ans = <STDIN>;
\&    exit 0 if $ans =~ /^[Xx]/;
.Ve
.Sp
See also \f(CW\*(C`die\*(C'\fR.  If \s-1EXPR\s0 is omitted, exits with \f(CW0\fR status.  The only
universally recognized values for \s-1EXPR\s0 are \f(CW0\fR for success and \f(CW1\fR
for error; other values are subject to interpretation depending on the
environment in which the Perl program is running.  For example, exiting
69 (\s-1EX_UNAVAILABLE\s0) from a \fIsendmail\fR incoming-mail filter will cause
the mailer to return the item undelivered, but that's not true everywhere.
.Sp
Don't use \f(CW\*(C`exit\*(C'\fR to abort a subroutine if there's any chance that
someone might want to trap whatever error happened.  Use \f(CW\*(C`die\*(C'\fR instead,
which can be trapped by an \f(CW\*(C`eval\*(C'\fR.
.Sp
The \fIexit()\fR function does not always exit immediately.  It calls any
defined \f(CW\*(C`END\*(C'\fR routines first, but these \f(CW\*(C`END\*(C'\fR routines may not
themselves abort the exit.  Likewise any object destructors that need to
be called are called before the real exit.  If this is a problem, you
can call \f(CW\*(C`POSIX:_exit($status)\*(C'\fR to avoid \s-1END\s0 and destructor processing.
See perlmod for details.
.IP "exp \s-1EXPR\s0" 8
.IX Xref "exp exponential antilog antilogarithm e"
.IX Item "exp EXPR"
.PD 0
.IP "exp" 8
.IX Item "exp"
.PD
Returns \fIe\fR (the natural logarithm base) to the power of \s-1EXPR\s0.
If \s-1EXPR\s0 is omitted, gives \f(CW\*(C`exp($_)\*(C'\fR.
.IP "fcntl \s-1FILEHANDLE\s0,FUNCTION,SCALAR" 8
.IX Xref "fcntl"
.IX Item "fcntl FILEHANDLE,FUNCTION,SCALAR"
Implements the \fIfcntl\fR\|(2) function.  You'll probably have to say
.Sp
.Vb 1
\&    use Fcntl;
.Ve
.Sp
first to get the correct constant definitions.  Argument processing and
value return works just like \f(CW\*(C`ioctl\*(C'\fR below.
For example:
.Sp
.Vb 3
\&    use Fcntl;
\&    fcntl($filehandle, F_GETFL, $packed_return_buffer)
\&        or die "can't fcntl F_GETFL: $!";
.Ve
.Sp
You don't have to check for \f(CW\*(C`defined\*(C'\fR on the return from \f(CW\*(C`fcntl\*(C'\fR.
Like \f(CW\*(C`ioctl\*(C'\fR, it maps a \f(CW0\fR return from the system call into
\&\f(CW"0 but true"\fR in Perl.  This string is true in boolean context and \f(CW0\fR
in numeric context.  It is also exempt from the normal \fB\-w\fR warnings
on improper numeric conversions.
.Sp
Note that \f(CW\*(C`fcntl\*(C'\fR will produce a fatal error if used on a machine that
doesn't implement \fIfcntl\fR\|(2).  See the Fcntl module or your \fIfcntl\fR\|(2)
manpage to learn what functions are available on your system.
.Sp
Here's an example of setting a filehandle named \f(CW\*(C`REMOTE\*(C'\fR to be
non-blocking at the system level.  You'll have to negotiate \f(CW$|\fR
on your own, though.
.Sp
.Vb 1
\&    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
.Ve
.Sp
.Vb 2
\&    $flags = fcntl(REMOTE, F_GETFL, 0)
\&                or die "Can't get flags for the socket: $!\en";
.Ve
.Sp
.Vb 2
\&    $flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
\&                or die "Can't set flags for the socket: $!\en";
.Ve
.IP "fileno \s-1FILEHANDLE\s0" 8
.IX Xref "fileno"
.IX Item "fileno FILEHANDLE"
Returns the file descriptor for a filehandle, or undefined if the
filehandle is not open.  This is mainly useful for constructing
bitmaps for \f(CW\*(C`select\*(C'\fR and low-level \s-1POSIX\s0 tty-handling operations.
If \s-1FILEHANDLE\s0 is an expression, the value is taken as an indirect
filehandle, generally its name.
.Sp
You can use this to find out whether two handles refer to the
same underlying descriptor:
.Sp
.Vb 3
\&    if (fileno(THIS) == fileno(THAT)) {
\&        print "THIS and THAT are dups\en";
\&    }
.Ve
.Sp
(Filehandles connected to memory objects via new features of \f(CW\*(C`open\*(C'\fR may
return undefined even though they are open.)
.IP "flock \s-1FILEHANDLE\s0,OPERATION" 8
.IX Xref "flock lock locking"
.IX Item "flock FILEHANDLE,OPERATION"
Calls \fIflock\fR\|(2), or an emulation of it, on \s-1FILEHANDLE\s0.  Returns true
for success, false on failure.  Produces a fatal error if used on a
machine that doesn't implement \fIflock\fR\|(2), \fIfcntl\fR\|(2) locking, or \fIlockf\fR\|(3).
\&\f(CW\*(C`flock\*(C'\fR is Perl's portable file locking interface, although it locks
only entire files, not records.
.Sp
Two potentially non-obvious but traditional \f(CW\*(C`flock\*(C'\fR semantics are
that it waits indefinitely until the lock is granted, and that its locks
\&\fBmerely advisory\fR.  Such discretionary locks are more flexible, but offer
fewer guarantees.  This means that programs that do not also use \f(CW\*(C`flock\*(C'\fR
may modify files locked with \f(CW\*(C`flock\*(C'\fR.  See perlport, 
your port's specific documentation, or your system-specific local manpages
for details.  It's best to assume traditional behavior if you're writing
portable programs.  (But if you're not, you should as always feel perfectly
free to write for your own system's idiosyncrasies (sometimes called
\&\*(L"features\*(R").  Slavish adherence to portability concerns shouldn't get
in the way of your getting your job done.)
.Sp
\&\s-1OPERATION\s0 is one of \s-1LOCK_SH\s0, \s-1LOCK_EX\s0, or \s-1LOCK_UN\s0, possibly combined with
\&\s-1LOCK_NB\s0.  These constants are traditionally valued 1, 2, 8 and 4, but
you can use the symbolic names if you import them from the Fcntl module,
either individually, or as a group using the ':flock' tag.  \s-1LOCK_SH\s0
requests a shared lock, \s-1LOCK_EX\s0 requests an exclusive lock, and \s-1LOCK_UN\s0
releases a previously requested lock.  If \s-1LOCK_NB\s0 is bitwise\-or'ed with
\&\s-1LOCK_SH\s0 or \s-1LOCK_EX\s0 then \f(CW\*(C`flock\*(C'\fR will return immediately rather than blocking
waiting for the lock (check the return status to see if you got it).
.Sp
To avoid the possibility of miscoordination, Perl now flushes \s-1FILEHANDLE\s0
before locking or unlocking it.
.Sp
Note that the emulation built with \fIlockf\fR\|(3) doesn't provide shared
locks, and it requires that \s-1FILEHANDLE\s0 be open with write intent.  These
are the semantics that \fIlockf\fR\|(3) implements.  Most if not all systems
implement \fIlockf\fR\|(3) in terms of \fIfcntl\fR\|(2) locking, though, so the
differing semantics shouldn't bite too many people.
.Sp
Note that the \fIfcntl\fR\|(2) emulation of \fIflock\fR\|(3) requires that \s-1FILEHANDLE\s0
be open with read intent to use \s-1LOCK_SH\s0 and requires that it be open
with write intent to use \s-1LOCK_EX\s0.
.Sp
Note also that some versions of \f(CW\*(C`flock\*(C'\fR cannot lock things over the
network; you would need to use the more system-specific \f(CW\*(C`fcntl\*(C'\fR for
that.  If you like you can force Perl to ignore your system's \fIflock\fR\|(2)
function, and so provide its own \fIfcntl\fR\|(2)\-based emulation, by passing
the switch \f(CW\*(C`\-Ud_flock\*(C'\fR to the \fIConfigure\fR program when you configure
perl.
.Sp
Here's a mailbox appender for \s-1BSD\s0 systems.
.Sp
.Vb 1
\&    use Fcntl ':flock'; # import LOCK_* constants
.Ve
.Sp
.Vb 6
\&    sub lock {
\&        flock(MBOX,LOCK_EX);
\&        # and, in case someone appended
\&        # while we were waiting...
\&        seek(MBOX, 0, 2);
\&    }
.Ve
.Sp
.Vb 3
\&    sub unlock {
\&        flock(MBOX,LOCK_UN);
\&    }
.Ve
.Sp
.Vb 2
\&    open(MBOX, ">>/usr/spool/mail/$ENV{'USER'}")
\&            or die "Can't open mailbox: $!";
.Ve
.Sp
.Vb 3
\&    lock();
\&    print MBOX $msg,"\en\en";
\&    unlock();
.Ve
.Sp
On systems that support a real \fIflock()\fR, locks are inherited across \fIfork()\fR
calls, whereas those that must resort to the more capricious \fIfcntl()\fR
function lose the locks, making it harder to write servers.
.Sp
See also DB_File for other \fIflock()\fR examples.
.IP "fork" 8
.IX Xref "fork child parent"
.IX Item "fork"
Does a \fIfork\fR\|(2) system call to create a new process running the
same program at the same point.  It returns the child pid to the
parent process, \f(CW0\fR to the child process, or \f(CW\*(C`undef\*(C'\fR if the fork is
unsuccessful.  File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.  On most systems supporting
\&\fIfork()\fR, great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.
.Sp
Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see perlport).  To be safe, you may need to set
\&\f(CW$|\fR ($AUTOFLUSH in English) or call the \f(CW\*(C`autoflush()\*(C'\fR method of
\&\f(CW\*(C`IO::Handle\*(C'\fR on any open handles in order to avoid duplicate output.
.Sp
If you \f(CW\*(C`fork\*(C'\fR without ever waiting on your children, you will
accumulate zombies.  On some systems, you can avoid this by setting
\&\f(CW$SIG{CHLD}\fR to \f(CW"IGNORE"\fR.  See also perlipc for more examples of
forking and reaping moribund children.
.Sp
Note that if your forked child inherits system file descriptors like
\&\s-1STDIN\s0 and \s-1STDOUT\s0 that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a \s-1CGI\s0 script or a
backgrounded job launched from a remote shell) won't think you're done.
You should reopen those to \fI/dev/null\fR if it's any issue.
.IP "format" 8
.IX Xref "format"
.IX Item "format"
Declare a picture format for use by the \f(CW\*(C`write\*(C'\fR function.  For
example:
.Sp
.Vb 4
\&    format Something =
\&        Test: @<<<<<<<< @||||| @>>>>>
\&              $str,     $%,    '$' . int($num)
\&    .
.Ve
.Sp
.Vb 4
\&    $str = "widget";
\&    $num = $cost/$quantity;
\&    $~ = 'Something';
\&    write;
.Ve
.Sp
See perlform for many details and examples.
.IP "formline \s-1PICTURE\s0,LIST" 8
.IX Xref "formline"
.IX Item "formline PICTURE,LIST"
This is an internal function used by \f(CW\*(C`format\*(C'\fRs, though you may call it,
too.  It formats (see perlform) a list of values according to the
contents of \s-1PICTURE\s0, placing the output into the format output
accumulator, \f(CW$^A\fR (or \f(CW$ACCUMULATOR\fR in English).
Eventually, when a \f(CW\*(C`write\*(C'\fR is done, the contents of
\&\f(CW$^A\fR are written to some filehandle.  You could also read \f(CW$^A\fR
and then set \f(CW$^A\fR back to \f(CW""\fR.  Note that a format typically
does one \f(CW\*(C`formline\*(C'\fR per line of form, but the \f(CW\*(C`formline\*(C'\fR function itself
doesn't care how many newlines are embedded in the \s-1PICTURE\s0.  This means
that the \f(CW\*(C`~\*(C'\fR and \f(CW\*(C`~~\*(C'\fR tokens will treat the entire \s-1PICTURE\s0 as a single line.
You may therefore need to use multiple formlines to implement a single
record format, just like the format compiler.
.Sp
Be careful if you put double quotes around the picture, because an \f(CW\*(C`@\*(C'\fR
character may be taken to mean the beginning of an array name.
\&\f(CW\*(C`formline\*(C'\fR always returns true.  See perlform for other examples.
.IP "getc \s-1FILEHANDLE\s0" 8
.IX Xref "getc getchar"
.IX Item "getc FILEHANDLE"
.PD 0
.IP "getc" 8
.IX Item "getc"
.PD
Returns the next character from the input file attached to \s-1FILEHANDLE\s0,
or the undefined value at end of file, or if there was an error (in
the latter case \f(CW$!\fR is set).  If \s-1FILEHANDLE\s0 is omitted, reads from
\&\s-1STDIN\s0.  This is not particularly efficient.  However, it cannot be
used by itself to fetch single characters without waiting for the user
to hit enter.  For that, try something more like:
.Sp
.Vb 6
\&    if ($BSD_STYLE) {
\&        system "stty cbreak </dev/tty >/dev/tty 2>&1";
\&    }
\&    else {
\&        system "stty", '-icanon', 'eol', "\e001";
\&    }
.Ve
.Sp
.Vb 1
\&    $key = getc(STDIN);
.Ve
.Sp
.Vb 7
\&    if ($BSD_STYLE) {
\&        system "stty -cbreak </dev/tty >/dev/tty 2>&1";
\&    }
\&    else {
\&        system "stty", 'icanon', 'eol', '^@'; # ASCII null
\&    }
\&    print "\en";
.Ve
.Sp
Determination of whether \f(CW$BSD_STYLE\fR should be set
is left as an exercise to the reader.
.Sp
The \f(CW\*(C`POSIX::getattr\*(C'\fR function can do this more portably on
systems purporting \s-1POSIX\s0 compliance.  See also the \f(CW\*(C`Term::ReadKey\*(C'\fR
module from your nearest \s-1CPAN\s0 site; details on \s-1CPAN\s0 can be found on
\&\*(L"\s-1CPAN\s0\*(R" in perlmodlib.
.IP "getlogin" 8
.IX Xref "getlogin login"
.IX Item "getlogin"
This implements the C library function of the same name, which on most
systems returns the current login from \fI/etc/utmp\fR, if any.  If null,
use \f(CW\*(C`getpwuid\*(C'\fR.
.Sp
.Vb 1
\&    $login = getlogin || getpwuid($<) || "Kilroy";
.Ve
.Sp
Do not consider \f(CW\*(C`getlogin\*(C'\fR for authentication: it is not as
secure as \f(CW\*(C`getpwuid\*(C'\fR.
.IP "getpeername \s-1SOCKET\s0" 8
.IX Xref "getpeername peer"
.IX Item "getpeername SOCKET"
Returns the packed sockaddr address of other end of the \s-1SOCKET\s0 connection.
.Sp
.Vb 5
\&    use Socket;
\&    $hersockaddr    = getpeername(SOCK);
\&    ($port, $iaddr) = sockaddr_in($hersockaddr);
\&    $herhostname    = gethostbyaddr($iaddr, AF_INET);
\&    $herstraddr     = inet_ntoa($iaddr);
.Ve
.IP "getpgrp \s-1PID\s0" 8
.IX Xref "getpgrp group"
.IX Item "getpgrp PID"
Returns the current process group for the specified \s-1PID\s0.  Use
a \s-1PID\s0 of \f(CW0\fR to get the current process group for the
current process.  Will raise an exception if used on a machine that
doesn't implement \fIgetpgrp\fR\|(2).  If \s-1PID\s0 is omitted, returns process
group of current process.  Note that the \s-1POSIX\s0 version of \f(CW\*(C`getpgrp\*(C'\fR
does not accept a \s-1PID\s0 argument, so only \f(CW\*(C`PID==0\*(C'\fR is truly portable.
.IP "getppid" 8
.IX Xref "getppid parent pid"
.IX Item "getppid"
Returns the process id of the parent process.
.Sp
Note for Linux users: on Linux, the C functions \f(CW\*(C`getpid()\*(C'\fR and
\&\f(CW\*(C`getppid()\*(C'\fR return different values from different threads. In order to
be portable, this behavior is not reflected by the perl-level function
\&\f(CW\*(C`getppid()\*(C'\fR, that returns a consistent value across threads. If you want
to call the underlying \f(CW\*(C`getppid()\*(C'\fR, you may use the \s-1CPAN\s0 module
\&\f(CW\*(C`Linux::Pid\*(C'\fR.
.IP "getpriority \s-1WHICH\s0,WHO" 8
.IX Xref "getpriority priority nice"
.IX Item "getpriority WHICH,WHO"
Returns the current priority for a process, a process group, or a user.
(See \fIgetpriority\fR\|(2).)  Will raise a fatal exception if used on a
machine that doesn't implement \fIgetpriority\fR\|(2).
.IP "getpwnam \s-1NAME\s0" 8
.IX Xref "getpwnam getgrnam gethostbyname getnetbyname getprotobyname getpwuid getgrgid getservbyname gethostbyaddr getnetbyaddr getprotobynumber getservbyport getpwent getgrent gethostent getnetent getprotoent getservent setpwent setgrent sethostent setnetent setprotoent setservent endpwent endgrent endhostent endnetent endprotoent endservent"
.IX Item "getpwnam NAME"
.PD 0
.IP "getgrnam \s-1NAME\s0" 8
.IX Item "getgrnam NAME"
.IP "gethostbyname \s-1NAME\s0" 8
.IX Item "gethostbyname NAME"
.IP "getnetbyname \s-1NAME\s0" 8
.IX Item "getnetbyname NAME"
.IP "getprotobyname \s-1NAME\s0" 8
.IX Item "getprotobyname NAME"
.IP "getpwuid \s-1UID\s0" 8
.IX Item "getpwuid UID"
.IP "getgrgid \s-1GID\s0" 8
.IX Item "getgrgid GID"
.IP "getservbyname \s-1NAME\s0,PROTO" 8
.IX Item "getservbyname NAME,PROTO"
.IP "gethostbyaddr \s-1ADDR\s0,ADDRTYPE" 8
.IX Item "gethostbyaddr ADDR,ADDRTYPE"
.IP "getnetbyaddr \s-1ADDR\s0,ADDRTYPE" 8
.IX Item "getnetbyaddr ADDR,ADDRTYPE"
.IP "getprotobynumber \s-1NUMBER\s0" 8
.IX Item "getprotobynumber NUMBER"
.IP "getservbyport \s-1PORT\s0,PROTO" 8
.IX Item "getservbyport PORT,PROTO"
.IP "getpwent" 8
.IX Item "getpwent"
.IP "getgrent" 8
.IX Item "getgrent"
.IP "gethostent" 8
.IX Item "gethostent"
.IP "getnetent" 8
.IX Item "getnetent"
.IP "getprotoent" 8
.IX Item "getprotoent"
.IP "getservent" 8
.IX Item "getservent"
.IP "setpwent" 8
.IX Item "setpwent"
.IP "setgrent" 8
.IX Item "setgrent"
.IP "sethostent \s-1STAYOPEN\s0" 8
.IX Item "sethostent STAYOPEN"
.IP "setnetent \s-1STAYOPEN\s0" 8
.IX Item "setnetent STAYOPEN"
.IP "setprotoent \s-1STAYOPEN\s0" 8
.IX Item "setprotoent STAYOPEN"
.IP "setservent \s-1STAYOPEN\s0" 8
.IX Item "setservent STAYOPEN"
.IP "endpwent" 8
.IX Item "endpwent"
.IP "endgrent" 8
.IX Item "endgrent"
.IP "endhostent" 8
.IX Item "endhostent"
.IP "endnetent" 8
.IX Item "endnetent"
.IP "endprotoent" 8
.IX Item "endprotoent"
.IP "endservent" 8
.IX Item "endservent"
.PD
These routines perform the same functions as their counterparts in the
system library.  In list context, the return values from the
various get routines are as follows:
.Sp
.Vb 7
\&    ($name,$passwd,$uid,$gid,
\&       $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*
\&    ($name,$passwd,$gid,$members) = getgr*
\&    ($name,$aliases,$addrtype,$length,@addrs) = gethost*
\&    ($name,$aliases,$addrtype,$net) = getnet*
\&    ($name,$aliases,$proto) = getproto*
\&    ($name,$aliases,$port,$proto) = getserv*
.Ve
.Sp
(If the entry doesn't exist you get a null list.)
.Sp
The exact meaning of the \f(CW$gcos\fR field varies but it usually contains
the real name of the user (as opposed to the login name) and other
information pertaining to the user.  Beware, however, that in many
system users are able to change this information and therefore it
cannot be trusted and therefore the \f(CW$gcos\fR is tainted (see
perlsec).  The \f(CW$passwd\fR and \f(CW$shell\fR, user's encrypted password and
login shell, are also tainted, because of the same reason.
.Sp
In scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:
.Sp
.Vb 7
\&    $uid   = getpwnam($name);
\&    $name  = getpwuid($num);
\&    $name  = getpwent();
\&    $gid   = getgrnam($name);
\&    $name  = getgrgid($num);
\&    $name  = getgrent();
\&    #etc.
.Ve
.Sp
In \fIgetpw*()\fR the fields \f(CW$quota\fR, \f(CW$comment\fR, and \f(CW$expire\fR are special
cases in the sense that in many systems they are unsupported.  If the
\&\f(CW$quota\fR is unsupported, it is an empty scalar.  If it is supported, it
usually encodes the disk quota.  If the \f(CW$comment\fR field is unsupported,
it is an empty scalar.  If it is supported it usually encodes some
administrative comment about the user.  In some systems the \f(CW$quota\fR
field may be \f(CW$change\fR or \f(CW$age\fR, fields that have to do with password
aging.  In some systems the \f(CW$comment\fR field may be \f(CW$class\fR.  The \f(CW$expire\fR
field, if present, encodes the expiration period of the account or the
password.  For the availability and the exact meaning of these fields
in your system, please consult your \fIgetpwnam\fR\|(3) documentation and your
\&\fIpwd.h\fR file.  You can also find out from within Perl what your
\&\f(CW$quota\fR and \f(CW$comment\fR fields mean and whether you have the \f(CW$expire\fR field
by using the \f(CW\*(C`Config\*(C'\fR module and the values \f(CW\*(C`d_pwquota\*(C'\fR, \f(CW\*(C`d_pwage\*(C'\fR,
\&\f(CW\*(C`d_pwchange\*(C'\fR, \f(CW\*(C`d_pwcomment\*(C'\fR, and \f(CW\*(C`d_pwexpire\*(C'\fR.  Shadow password
files are only supported if your vendor has implemented them in the
intuitive fashion that calling the regular C library routines gets the
shadow versions if you're running under privilege or if there exists
the \fIshadow\fR\|(3) functions as found in System V (this includes Solaris
and Linux.)  Those systems that implement a proprietary shadow password
facility are unlikely to be supported.
.Sp
The \f(CW$members\fR value returned by \fIgetgr*()\fR is a space separated list of
the login names of the members of the group.
.Sp
For the \fIgethost*()\fR functions, if the \f(CW\*(C`h_errno\*(C'\fR variable is supported in
C, it will be returned to you via \f(CW$?\fR if the function call fails.  The
\&\f(CW@addrs\fR value returned by a successful call is a list of the raw
addresses returned by the corresponding system library call.  In the
Internet domain, each address is four bytes long and you can unpack it
by saying something like:
.Sp
.Vb 1
\&    ($a,$b,$c,$d) = unpack('C4',$addr[0]);
.Ve
.Sp
The Socket library makes this slightly easier:
.Sp
.Vb 3
\&    use Socket;
\&    $iaddr = inet_aton("127.1"); # or whatever address
\&    $name  = gethostbyaddr($iaddr, AF_INET);
.Ve
.Sp
.Vb 2
\&    # or going the other way
\&    $straddr = inet_ntoa($iaddr);
.Ve
.Sp
If you get tired of remembering which element of the return list
contains which return value, by-name interfaces are provided
in standard modules: \f(CW\*(C`File::stat\*(C'\fR, \f(CW\*(C`Net::hostent\*(C'\fR, \f(CW\*(C`Net::netent\*(C'\fR,
\&\f(CW\*(C`Net::protoent\*(C'\fR, \f(CW\*(C`Net::servent\*(C'\fR, \f(CW\*(C`Time::gmtime\*(C'\fR, \f(CW\*(C`Time::localtime\*(C'\fR,
and \f(CW\*(C`User::grent\*(C'\fR.  These override the normal built\-ins, supplying
versions that return objects with the appropriate names
for each field.  For example:
.Sp
.Vb 3
\&   use File::stat;
\&   use User::pwent;
\&   $is_his = (stat($filename)->uid == pwent($whoever)->uid);
.Ve
.Sp
Even though it looks like they're the same method calls (uid),
they aren't, because a \f(CW\*(C`File::stat\*(C'\fR object is different from
a \f(CW\*(C`User::pwent\*(C'\fR object.
.IP "getsockname \s-1SOCKET\s0" 8
.IX Xref "getsockname"
.IX Item "getsockname SOCKET"
Returns the packed sockaddr address of this end of the \s-1SOCKET\s0 connection,
in case you don't know the address because you have several different
IPs that the connection might have come in on.
.Sp
.Vb 6
\&    use Socket;
\&    $mysockaddr = getsockname(SOCK);
\&    ($port, $myaddr) = sockaddr_in($mysockaddr);
\&    printf "Connect to %s [%s]\en",
\&       scalar gethostbyaddr($myaddr, AF_INET),
\&       inet_ntoa($myaddr);
.Ve
.IP "getsockopt \s-1SOCKET\s0,LEVEL,OPTNAME" 8
.IX Xref "getsockopt"
.IX Item "getsockopt SOCKET,LEVEL,OPTNAME"
Queries the option named \s-1OPTNAME\s0 associated with \s-1SOCKET\s0 at a given \s-1LEVEL\s0.
Options may exist at multiple protocol levels depending on the socket
type, but at least the uppermost socket level \s-1SOL_SOCKET\s0 (defined in the
\&\f(CW\*(C`Socket\*(C'\fR module) will exist. To query options at another level the
protocol number of the appropriate protocol controlling the option
should be supplied. For example, to indicate that an option is to be
interpreted by the \s-1TCP\s0 protocol, \s-1LEVEL\s0 should be set to the protocol
number of \s-1TCP\s0, which you can get using getprotobyname.
.Sp
The call returns a packed string representing the requested socket option,
or \f(CW\*(C`undef\*(C'\fR if there is an error (the error reason will be in $!). What
exactly is in the packed string depends in the \s-1LEVEL\s0 and \s-1OPTNAME\s0, consult
your system documentation for details. A very common case however is that
the option is an integer, in which case the result will be a packed
integer which you can decode using unpack with the \f(CW\*(C`i\*(C'\fR (or \f(CW\*(C`I\*(C'\fR) format.
.Sp
An example testing if Nagle's algorithm is turned on on a socket:
.Sp
.Vb 1
\&    use Socket qw(:all);
.Ve
.Sp
.Vb 7
\&    defined(my $tcp = getprotobyname("tcp"))
\&        or die "Could not determine the protocol number for tcp";
\&    # my $tcp = IPPROTO_TCP; # Alternative
\&    my $packed = getsockopt($socket, $tcp, TCP_NODELAY)
\&        or die "Could not query TCP_NODELAY socket option: $!";
\&    my $nodelay = unpack("I", $packed);
\&    print "Nagle's algorithm is turned ", $nodelay ? "off\en" : "on\en";
.Ve
.IP "glob \s-1EXPR\s0" 8
.IX Xref "glob wildcard filename, expansion expand"
.IX Item "glob EXPR"
.PD 0
.IP "glob" 8
.IX Item "glob"
.PD
In list context, returns a (possibly empty) list of filename expansions on
the value of \s-1EXPR\s0 such as the standard Unix shell \fI/bin/csh\fR would do. In
scalar context, glob iterates through such filename expansions, returning
undef when the list is exhausted. This is the internal function
implementing the \f(CW\*(C`<*.c>\*(C'\fR operator, but you can use it directly. If
\&\s-1EXPR\s0 is omitted, \f(CW$_\fR is used.  The \f(CW\*(C`<*.c>\*(C'\fR operator is discussed in
more detail in \*(L"I/O Operators\*(R" in perlop.
.Sp
Beginning with v5.6.0, this operator is implemented using the standard
\&\f(CW\*(C`File::Glob\*(C'\fR extension.  See File::Glob for details.
.IP "gmtime \s-1EXPR\s0" 8
.IX Xref "gmtime UTC Greenwich"
.IX Item "gmtime EXPR"
.PD 0
.IP "gmtime" 8
.IX Item "gmtime"
.PD
Converts a time as returned by the time function to an 9\-element list
with the time localized for the standard Greenwich time zone.
Typically used as follows:
.Sp
.Vb 3
\&    #  0    1    2     3     4    5     6     7     8
\&    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
\&                                            gmtime(time);
.Ve
.Sp
All list elements are numeric, and come straight out of the C `struct
tm'.  \f(CW$sec\fR, \f(CW$min\fR, and \f(CW$hour\fR are the seconds, minutes, and hours of the
specified time.  \f(CW$mday\fR is the day of the month, and \f(CW$mon\fR is the month
itself, in the range \f(CW0..11\fR with 0 indicating January and 11
indicating December.  \f(CW$year\fR is the number of years since 1900.  That
is, \f(CW$year\fR is \f(CW123\fR in year 2023.  \f(CW$wday\fR is the day of the week, with
0 indicating Sunday and 3 indicating Wednesday.  \f(CW$yday\fR is the day of
the year, in the range \f(CW0..364\fR (or \f(CW0..365\fR in leap years).  \f(CW$isdst\fR
is always \f(CW0\fR.
.Sp
Note that the \f(CW$year\fR element is \fInot\fR simply the last two digits of
the year.  If you assume it is then you create non\-Y2K\-compliant
programs\*(--and you wouldn't want to do that, would you?
.Sp
The proper way to get a complete 4\-digit year is simply:
.Sp
.Vb 1
\&        $year += 1900;
.Ve
.Sp
And to get the last two digits of the year (e.g., '01' in 2001) do:
.Sp
.Vb 1
\&        $year = sprintf("%02d", $year % 100);
.Ve
.Sp
If \s-1EXPR\s0 is omitted, \f(CW\*(C`gmtime()\*(C'\fR uses the current time (\f(CW\*(C`gmtime(time)\*(C'\fR).
.Sp
In scalar context, \f(CW\*(C`gmtime()\*(C'\fR returns the \fIctime\fR\|(3) value:
.Sp
.Vb 1
\&    $now_string = gmtime;  # e.g., "Thu Oct 13 04:54:34 1994"
.Ve
.Sp
If you need local time instead of \s-1GMT\s0 use the \*(L"localtime\*(R" builtin. 
See also the \f(CW\*(C`timegm\*(C'\fR function provided by the \f(CW\*(C`Time::Local\*(C'\fR module,
and the \fIstrftime\fR\|(3) and \fImktime\fR\|(3) functions available via the \s-1POSIX\s0 module.
.Sp
This scalar value is \fBnot\fR locale dependent (see perllocale), but is
instead a Perl builtin.  To get somewhat similar but locale dependent date
strings, see the example in \*(L"localtime\*(R".
.Sp
See \*(L"gmtime\*(R" in perlport for portability concerns.
.IP "goto \s-1LABEL\s0" 8
.IX Xref "goto jump jmp"
.IX Item "goto LABEL"
.PD 0
.IP "goto \s-1EXPR\s0" 8
.IX Item "goto EXPR"
.IP "goto &NAME" 8
.IX Item "goto &NAME"
.PD
The \f(CW\*(C`goto\-LABEL\*(C'\fR form finds the statement labeled with \s-1LABEL\s0 and resumes
execution there.  It may not be used to go into any construct that
requires initialization, such as a subroutine or a \f(CW\*(C`foreach\*(C'\fR loop.  It
also can't be used to go into a construct that is optimized away,
or to get out of a block or subroutine given to \f(CW\*(C`sort\*(C'\fR.
It can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as \f(CW\*(C`last\*(C'\fR or \f(CW\*(C`die\*(C'\fR.  The author of Perl has never felt the
need to use this form of \f(CW\*(C`goto\*(C'\fR (in Perl, that is\*(--C is another matter).
(The difference being that C does not offer named loops combined with
loop control.  Perl does, and this replaces most structured uses of \f(CW\*(C`goto\*(C'\fR
in other languages.)
.Sp
The \f(CW\*(C`goto\-EXPR\*(C'\fR form expects a label name, whose scope will be resolved
dynamically.  This allows for computed \f(CW\*(C`goto\*(C'\fRs per \s-1FORTRAN\s0, but isn't
necessarily recommended if you're optimizing for maintainability:
.Sp
.Vb 1
\&    goto ("FOO", "BAR", "GLARCH")[$i];
.Ve
.Sp
The \f(CW\*(C`goto\-&NAME\*(C'\fR form is quite different from the other forms of
\&\f(CW\*(C`goto\*(C'\fR.  In fact, it isn't a goto in the normal sense at all, and
doesn't have the stigma associated with other gotos.  Instead, it
exits the current subroutine (losing any changes set by \fIlocal()\fR) and
immediately calls in its place the named subroutine using the current
value of \f(CW@_\fR.  This is used by \f(CW\*(C`AUTOLOAD\*(C'\fR subroutines that wish to
load another subroutine and then pretend that the other subroutine had
been called in the first place (except that any modifications to \f(CW@_\fR
in the current subroutine are propagated to the other subroutine.)
After the \f(CW\*(C`goto\*(C'\fR, not even \f(CW\*(C`caller\*(C'\fR will be able to tell that this
routine was called first.
.Sp
\&\s-1NAME\s0 needn't be the name of a subroutine; it can be a scalar variable
containing a code reference, or a block that evaluates to a code
reference.
.IP "grep \s-1BLOCK\s0 \s-1LIST\s0" 8
.IX Xref "grep"
.IX Item "grep BLOCK LIST"
.PD 0
.IP "grep \s-1EXPR\s0,LIST" 8
.IX Item "grep EXPR,LIST"
.PD
This is similar in spirit to, but not the same as, \fIgrep\fR\|(1) and its
relatives.  In particular, it is not limited to using regular expressions.
.Sp
Evaluates the \s-1BLOCK\s0 or \s-1EXPR\s0 for each element of \s-1LIST\s0 (locally setting
\&\f(CW$_\fR to each element) and returns the list value consisting of those
elements for which the expression evaluated to true.  In scalar
context, returns the number of times the expression was true.
.Sp
.Vb 1
\&    @foo = grep(!/^#/, @bar);    # weed out comments
.Ve
.Sp
or equivalently,
.Sp
.Vb 1
\&    @foo = grep {!/^#/} @bar;    # weed out comments
.Ve
.Sp
Note that \f(CW$_\fR is an alias to the list value, so it can be used to
modify the elements of the \s-1LIST\s0.  While this is useful and supported,
it can cause bizarre results if the elements of \s-1LIST\s0 are not variables.
Similarly, grep returns aliases into the original list, much as a for
loop's index variable aliases the list elements.  That is, modifying an
element of a list returned by grep (for example, in a \f(CW\*(C`foreach\*(C'\fR, \f(CW\*(C`map\*(C'\fR
or another \f(CW\*(C`grep\*(C'\fR) actually modifies the element in the original list.
This is usually something to be avoided when writing clear code.
.Sp
See also \*(L"map\*(R" for a list composed of the results of the \s-1BLOCK\s0 or \s-1EXPR\s0.
.IP "hex \s-1EXPR\s0" 8
.IX Xref "hex hexadecimal"
.IX Item "hex EXPR"
.PD 0
.IP "hex" 8
.IX Item "hex"
.PD
Interprets \s-1EXPR\s0 as a hex string and returns the corresponding value.
(To convert strings that might start with either \f(CW0\fR, \f(CW\*(C`0x\*(C'\fR, or \f(CW\*(C`0b\*(C'\fR, see
\&\*(L"oct\*(R".)  If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
.Vb 2
\&    print hex '0xAf'; # prints '175'
\&    print hex 'aF';   # same
.Ve
.Sp
Hex strings may only represent integers.  Strings that would cause
integer overflow trigger a warning.  Leading whitespace is not stripped,
unlike \fIoct()\fR. To present something as hex, look into \*(L"printf\*(R",
\&\*(L"sprintf\*(R", or \*(L"unpack\*(R".
.IP "import \s-1LIST\s0" 8
.IX Xref "import"
.IX Item "import LIST"
There is no builtin \f(CW\*(C`import\*(C'\fR function.  It is just an ordinary
method (subroutine) defined (or inherited) by modules that wish to export
names to another module.  The \f(CW\*(C`use\*(C'\fR function calls the \f(CW\*(C`import\*(C'\fR method
for the package used.  See also \*(L"use\*(R", perlmod, and Exporter.
.IP "index \s-1STR\s0,SUBSTR,POSITION" 8
.IX Xref "index indexOf InStr"
.IX Item "index STR,SUBSTR,POSITION"
.PD 0
.IP "index \s-1STR\s0,SUBSTR" 8
.IX Item "index STR,SUBSTR"
.PD
The index function searches for one string within another, but without
the wildcard-like behavior of a full regular-expression pattern match.
It returns the position of the first occurrence of \s-1SUBSTR\s0 in \s-1STR\s0 at
or after \s-1POSITION\s0.  If \s-1POSITION\s0 is omitted, starts searching from the
beginning of the string.  \s-1POSITION\s0 before the beginning of the string
or after its end is treated as if it were the beginning or the end,
respectively.  \s-1POSITION\s0 and the return value are based at \f(CW0\fR (or whatever
you've set the \f(CW$[\fR variable to\*(--but don't do that).  If the substring
is not found, \f(CW\*(C`index\*(C'\fR returns one less than the base, ordinarily \f(CW\*(C`\-1\*(C'\fR.
.IP "int \s-1EXPR\s0" 8
.IX Xref "int integer truncate trunc"
.IX Item "int EXPR"
.PD 0
.IP "int" 8
.IX Item "int"
.PD
Returns the integer portion of \s-1EXPR\s0.  If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
You should not use this function for rounding: one because it truncates
towards \f(CW0\fR, and two because machine representations of floating point
numbers can sometimes produce counterintuitive results.  For example,
\&\f(CW\*(C`int(\-6.725/0.025)\*(C'\fR produces \-268 rather than the correct \-269; that's
because it's really more like \-268.99999999999994315658 instead.  Usually,
the \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, or the \f(CW\*(C`POSIX::floor\*(C'\fR and \f(CW\*(C`POSIX::ceil\*(C'\fR
functions will serve you better than will \fIint()\fR.
.IP "ioctl \s-1FILEHANDLE\s0,FUNCTION,SCALAR" 8
.IX Xref "ioctl"
.IX Item "ioctl FILEHANDLE,FUNCTION,SCALAR"
Implements the \fIioctl\fR\|(2) function.  You'll probably first have to say
.Sp
.Vb 1
\&    require "sys/ioctl.ph";     # probably in $Config{archlib}/sys/ioctl.ph
.Ve
.Sp
to get the correct function definitions.  If \fIsys/ioctl.ph\fR doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as \fI<sys/ioctl.h>\fR.
(There is a Perl script called \fBh2ph\fR that comes with the Perl kit that
may help you in this, but it's nontrivial.)  \s-1SCALAR\s0 will be read and/or
written depending on the FUNCTION\*(--a pointer to the string value of \s-1SCALAR\s0
will be passed as the third argument of the actual \f(CW\*(C`ioctl\*(C'\fR call.  (If \s-1SCALAR\s0
has no string value but does have a numeric value, that value will be
passed rather than a pointer to the string value.  To guarantee this to be
true, add a \f(CW0\fR to the scalar before using it.)  The \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
functions may be needed to manipulate the values of structures used by
\&\f(CW\*(C`ioctl\*(C'\fR.
.Sp
The return value of \f(CW\*(C`ioctl\*(C'\fR (and \f(CW\*(C`fcntl\*(C'\fR) is as follows:
.Sp
.Vb 4
\&        if OS returns:          then Perl returns:
\&            -1                    undefined value
\&             0                  string "0 but true"
\&        anything else               that number
.Ve
.Sp
Thus Perl returns true on success and false on failure, yet you can
still easily determine the actual value returned by the operating
system:
.Sp
.Vb 2
\&    $retval = ioctl(...) || -1;
\&    printf "System returned %d\en", $retval;
.Ve
.Sp
The special string \f(CW"0 but true"\fR is exempt from \fB\-w\fR complaints
about improper numeric conversions.
.IP "join \s-1EXPR\s0,LIST" 8
.IX Xref "join"
.IX Item "join EXPR,LIST"
Joins the separate strings of \s-1LIST\s0 into a single string with fields
separated by the value of \s-1EXPR\s0, and returns that new string.  Example:
.Sp
.Vb 1
\&    $rec = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);
.Ve
.Sp
Beware that unlike \f(CW\*(C`split\*(C'\fR, \f(CW\*(C`join\*(C'\fR doesn't take a pattern as its
first argument.  Compare \*(L"split\*(R".
.IP "keys \s-1HASH\s0" 8
.IX Xref "keys key"
.IX Item "keys HASH"
Returns a list consisting of all the keys of the named hash.
(In scalar context, returns the number of keys.)
.Sp
The keys are returned in an apparently random order.  The actual
random order is subject to change in future versions of perl, but it
is guaranteed to be the same order as either the \f(CW\*(C`values\*(C'\fR or \f(CW\*(C`each\*(C'\fR
function produces (given that the hash has not been modified).  Since
Perl 5.8.1 the ordering is different even between different runs of
Perl for security reasons (see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec).
.Sp
As a side effect, calling \fIkeys()\fR resets the \s-1HASH\s0's internal iterator
(see \*(L"each\*(R").  In particular, calling \fIkeys()\fR in void context resets
the iterator with no other overhead.
.Sp
Here is yet another way to print your environment:
.Sp
.Vb 5
\&    @keys = keys %ENV;
\&    @values = values %ENV;
\&    while (@keys) {
\&        print pop(@keys), '=', pop(@values), "\en";
\&    }
.Ve
.Sp
or how about sorted by key:
.Sp
.Vb 3
\&    foreach $key (sort(keys %ENV)) {
\&        print $key, '=', $ENV{$key}, "\en";
\&    }
.Ve
.Sp
The returned values are copies of the original keys in the hash, so
modifying them will not affect the original hash.  Compare \*(L"values\*(R".
.Sp
To sort a hash by value, you'll need to use a \f(CW\*(C`sort\*(C'\fR function.
Here's a descending numeric sort of a hash by its values:
.Sp
.Vb 3
\&    foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
\&        printf "%4d %s\en", $hash{$key}, $key;
\&    }
.Ve
.Sp
As an lvalue \f(CW\*(C`keys\*(C'\fR allows you to increase the number of hash buckets
allocated for the given hash.  This can gain you a measure of efficiency if
you know the hash is going to get big.  (This is similar to pre-extending
an array by assigning a larger number to $#array.)  If you say
.Sp
.Vb 1
\&    keys %hash = 200;
.Ve
.Sp
then \f(CW%hash\fR will have at least 200 buckets allocated for it\-\-256 of them,
in fact, since it rounds up to the next power of two.  These
buckets will be retained even if you do \f(CW\*(C`%hash = ()\*(C'\fR, use \f(CW\*(C`undef
%hash\*(C'\fR if you want to free the storage while \f(CW%hash\fR is still in scope.
You can't shrink the number of buckets allocated for the hash using
\&\f(CW\*(C`keys\*(C'\fR in this way (but you needn't worry about doing this by accident,
as trying has no effect).
.Sp
See also \f(CW\*(C`each\*(C'\fR, \f(CW\*(C`values\*(C'\fR and \f(CW\*(C`sort\*(C'\fR.
.IP "kill \s-1SIGNAL\s0, \s-1LIST\s0" 8
.IX Xref "kill signal"
.IX Item "kill SIGNAL, LIST"
Sends a signal to a list of processes.  Returns the number of
processes successfully signaled (which is not necessarily the
same as the number actually killed).
.Sp
.Vb 2
\&    $cnt = kill 1, $child1, $child2;
\&    kill 9, @goners;
.Ve
.Sp
If \s-1SIGNAL\s0 is zero, no signal is sent to the process.  This is a
useful way to check that a child process is alive and hasn't changed
its \s-1UID\s0.  See perlport for notes on the portability of this
construct.
.Sp
Unlike in the shell, if \s-1SIGNAL\s0 is negative, it kills
process groups instead of processes.  (On System V, a negative \fI\s-1PROCESS\s0\fR
number will also kill process groups, but that's not portable.)  That
means you usually want to use positive not negative signals.  You may also
use a signal name in quotes.
.Sp
See \*(L"Signals\*(R" in perlipc for more details.
.IP "last \s-1LABEL\s0" 8
.IX Xref "last break"
.IX Item "last LABEL"
.PD 0
.IP "last" 8
.IX Item "last"
.PD
The \f(CW\*(C`last\*(C'\fR command is like the \f(CW\*(C`break\*(C'\fR statement in C (as used in
loops); it immediately exits the loop in question.  If the \s-1LABEL\s0 is
omitted, the command refers to the innermost enclosing loop.  The
\&\f(CW\*(C`continue\*(C'\fR block, if any, is not executed:
.Sp
.Vb 4
\&    LINE: while (<STDIN>) {
\&        last LINE if /^$/;      # exit when done with header
\&        #...
\&    }
.Ve
.Sp
\&\f(CW\*(C`last\*(C'\fR cannot be used to exit a block which returns a value such as
\&\f(CW\*(C`eval {}\*(C'\fR, \f(CW\*(C`sub {}\*(C'\fR or \f(CW\*(C`do {}\*(C'\fR, and should not be used to exit
a \fIgrep()\fR or \fImap()\fR operation.
.Sp
Note that a block by itself is semantically identical to a loop
that executes once.  Thus \f(CW\*(C`last\*(C'\fR can be used to effect an early
exit out of such a block.
.Sp
See also \*(L"continue\*(R" for an illustration of how \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, and
\&\f(CW\*(C`redo\*(C'\fR work.
.IP "lc \s-1EXPR\s0" 8
.IX Xref "lc lowercase"
.IX Item "lc EXPR"
.PD 0
.IP "lc" 8
.IX Item "lc"
.PD
Returns a lowercased version of \s-1EXPR\s0.  This is the internal function
implementing the \f(CW\*(C`\eL\*(C'\fR escape in double-quoted strings.  Respects
current \s-1LC_CTYPE\s0 locale if \f(CW\*(C`use locale\*(C'\fR in force.  See perllocale
and perlunicode for more details about locale and Unicode support.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.IP "lcfirst \s-1EXPR\s0" 8
.IX Xref "lcfirst lowercase"
.IX Item "lcfirst EXPR"
.PD 0
.IP "lcfirst" 8
.IX Item "lcfirst"
.PD
Returns the value of \s-1EXPR\s0 with the first character lowercased.  This
is the internal function implementing the \f(CW\*(C`\el\*(C'\fR escape in
double-quoted strings.  Respects current \s-1LC_CTYPE\s0 locale if \f(CW\*(C`use
locale\*(C'\fR in force.  See perllocale and perlunicode for more
details about locale and Unicode support.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.IP "length \s-1EXPR\s0" 8
.IX Xref "length size"
.IX Item "length EXPR"
.PD 0
.IP "length" 8
.IX Item "length"
.PD
Returns the length in \fIcharacters\fR of the value of \s-1EXPR\s0.  If \s-1EXPR\s0 is
omitted, returns length of \f(CW$_\fR.  Note that this cannot be used on
an entire array or hash to find out how many elements these have.
For that, use \f(CW\*(C`scalar @array\*(C'\fR and \f(CW\*(C`scalar keys %hash\*(C'\fR respectively.
.Sp
Note the \fIcharacters\fR: if the \s-1EXPR\s0 is in Unicode, you will get the
number of characters, not the number of bytes.  To get the length
in bytes, use \f(CW\*(C`do { use bytes; length(EXPR) }\*(C'\fR, see bytes.
.IP "link \s-1OLDFILE\s0,NEWFILE" 8
.IX Xref "link"
.IX Item "link OLDFILE,NEWFILE"
Creates a new filename linked to the old filename.  Returns true for
success, false otherwise.
.IP "listen \s-1SOCKET\s0,QUEUESIZE" 8
.IX Xref "listen"
.IX Item "listen SOCKET,QUEUESIZE"
Does the same thing that the listen system call does.  Returns true if
it succeeded, false otherwise.  See the example in
\&\*(L"Sockets: Client/Server Communication\*(R" in perlipc.
.IP "local \s-1EXPR\s0" 8
.IX Xref "local"
.IX Item "local EXPR"
You really probably want to be using \f(CW\*(C`my\*(C'\fR instead, because \f(CW\*(C`local\*(C'\fR isn't
what most people think of as \*(L"local\*(R".  See
\&\*(L"Private Variables via \fImy()\fR\*(R" in perlsub for details.
.Sp
A local modifies the listed variables to be local to the enclosing
block, file, or eval.  If more than one value is listed, the list must
be placed in parentheses.  See \*(L"Temporary Values via \fIlocal()\fR\*(R" in perlsub
for details, including issues with tied arrays and hashes.
.IP "localtime \s-1EXPR\s0" 8
.IX Xref "localtime"
.IX Item "localtime EXPR"
.PD 0
.IP "localtime" 8
.IX Item "localtime"
.PD
Converts a time as returned by the time function to a 9\-element list
with the time analyzed for the local time zone.  Typically used as
follows:
.Sp
.Vb 3
\&    #  0    1    2     3     4    5     6     7     8
\&    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
\&                                                localtime(time);
.Ve
.Sp
All list elements are numeric, and come straight out of the C `struct
tm'.  \f(CW$sec\fR, \f(CW$min\fR, and \f(CW$hour\fR are the seconds, minutes, and hours
of the specified time.
.Sp
\&\f(CW$mday\fR is the day of the month, and \f(CW$mon\fR is the month itself, in
the range \f(CW0..11\fR with 0 indicating January and 11 indicating December.
This makes it easy to get a month name from a list:
.Sp
.Vb 3
\&    my @abbr = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
\&    print "$abbr[$mon] $mday";
\&    # $mon=9, $mday=18 gives "Oct 18"
.Ve
.Sp
\&\f(CW$year\fR is the number of years since 1900, not just the last two digits
of the year.  That is, \f(CW$year\fR is \f(CW123\fR in year 2023.  The proper way
to get a complete 4\-digit year is simply:
.Sp
.Vb 1
\&    $year += 1900;
.Ve
.Sp
To get the last two digits of the year (e.g., '01' in 2001) do:
.Sp
.Vb 1
\&    $year = sprintf("%02d", $year % 100);
.Ve
.Sp
\&\f(CW$wday\fR is the day of the week, with 0 indicating Sunday and 3 indicating
Wednesday.  \f(CW$yday\fR is the day of the year, in the range \f(CW0..364\fR
(or \f(CW0..365\fR in leap years.)
.Sp
\&\f(CW$isdst\fR is true if the specified time occurs during Daylight Saving
Time, false otherwise.
.Sp
If \s-1EXPR\s0 is omitted, \f(CW\*(C`localtime()\*(C'\fR uses the current time (\f(CW\*(C`localtime(time)\*(C'\fR).
.Sp
In scalar context, \f(CW\*(C`localtime()\*(C'\fR returns the \fIctime\fR\|(3) value:
.Sp
.Vb 1
\&    $now_string = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"
.Ve
.Sp
This scalar value is \fBnot\fR locale dependent but is a Perl builtin. For \s-1GMT\s0
instead of local time use the \*(L"gmtime\*(R" builtin. See also the
\&\f(CW\*(C`Time::Local\*(C'\fR module (to convert the second, minutes, hours, ... back to
the integer value returned by \fItime()\fR), and the \s-1POSIX\s0 module's \fIstrftime\fR\|(3)
and \fImktime\fR\|(3) functions.
.Sp
To get somewhat similar but locale dependent date strings, set up your
locale environment variables appropriately (please see perllocale) and
try for example:
.Sp
.Vb 4
\&    use POSIX qw(strftime);
\&    $now_string = strftime "%a %b %e %H:%M:%S %Y", localtime;
\&    # or for GMT formatted appropriately for your locale:
\&    $now_string = strftime "%a %b %e %H:%M:%S %Y", gmtime;
.Ve
.Sp
Note that the \f(CW%a\fR and \f(CW%b\fR, the short forms of the day of the week
and the month of the year, may not necessarily be three characters wide.
.Sp
See \*(L"localtime\*(R" in perlport for portability concerns.
.IP "lock \s-1THING\s0" 8
.IX Xref "lock"
.IX Item "lock THING"
This function places an advisory lock on a shared variable, or referenced
object contained in \fI\s-1THING\s0\fR until the lock goes out of scope.
.Sp
\&\fIlock()\fR is a \*(L"weak keyword\*(R" : this means that if you've defined a function
by this name (before any calls to it), that function will be called
instead. (However, if you've said \f(CW\*(C`use threads\*(C'\fR, \fIlock()\fR is always a
keyword.) See threads.
.IP "log \s-1EXPR\s0" 8
.IX Xref "log logarithm e ln base"
.IX Item "log EXPR"
.PD 0
.IP "log" 8
.IX Item "log"
.PD
Returns the natural logarithm (base \fIe\fR) of \s-1EXPR\s0.  If \s-1EXPR\s0 is omitted,
returns log of \f(CW$_\fR.  To get the log of another base, use basic algebra:
The base-N log of a number is equal to the natural log of that number
divided by the natural log of N.  For example:
.Sp
.Vb 4
\&    sub log10 {
\&        my $n = shift;
\&        return log($n)/log(10);
\&    }
.Ve
.Sp
See also \*(L"exp\*(R" for the inverse operation.
.IP "lstat \s-1EXPR\s0" 8
.IX Xref "lstat"
.IX Item "lstat EXPR"
.PD 0
.IP "lstat" 8
.IX Item "lstat"
.PD
Does the same thing as the \f(CW\*(C`stat\*(C'\fR function (including setting the
special \f(CW\*(C`_\*(C'\fR filehandle) but stats a symbolic link instead of the file
the symbolic link points to.  If symbolic links are unimplemented on
your system, a normal \f(CW\*(C`stat\*(C'\fR is done.  For much more detailed
information, please see the documentation for \*(L"stat\*(R".
.Sp
If \s-1EXPR\s0 is omitted, stats \f(CW$_\fR.
.IP "m//" 8
.IX Item "m//"
The match operator.  See perlop.
.IP "map \s-1BLOCK\s0 \s-1LIST\s0" 8
.IX Xref "map"
.IX Item "map BLOCK LIST"
.PD 0
.IP "map \s-1EXPR\s0,LIST" 8
.IX Item "map EXPR,LIST"
.PD
Evaluates the \s-1BLOCK\s0 or \s-1EXPR\s0 for each element of \s-1LIST\s0 (locally setting
\&\f(CW$_\fR to each element) and returns the list value composed of the
results of each such evaluation.  In scalar context, returns the
total number of elements so generated.  Evaluates \s-1BLOCK\s0 or \s-1EXPR\s0 in
list context, so each element of \s-1LIST\s0 may produce zero, one, or
more elements in the returned value.
.Sp
.Vb 1
\&    @chars = map(chr, @nums);
.Ve
.Sp
translates a list of numbers to the corresponding characters.  And
.Sp
.Vb 1
\&    %hash = map { getkey($_) => $_ } @array;
.Ve
.Sp
is just a funny way to write
.Sp
.Vb 4
\&    %hash = ();
\&    foreach $_ (@array) {
\&        $hash{getkey($_)} = $_;
\&    }
.Ve
.Sp
Note that \f(CW$_\fR is an alias to the list value, so it can be used to
modify the elements of the \s-1LIST\s0.  While this is useful and supported,
it can cause bizarre results if the elements of \s-1LIST\s0 are not variables.
Using a regular \f(CW\*(C`foreach\*(C'\fR loop for this purpose would be clearer in
most cases.  See also \*(L"grep\*(R" for an array composed of those items of
the original list for which the \s-1BLOCK\s0 or \s-1EXPR\s0 evaluates to true.
.Sp
\&\f(CW\*(C`{\*(C'\fR starts both hash references and blocks, so \f(CW\*(C`map { ...\*(C'\fR could be either
the start of map \s-1BLOCK\s0 \s-1LIST\s0 or map \s-1EXPR\s0, \s-1LIST\s0. Because perl doesn't look
ahead for the closing \f(CW\*(C`}\*(C'\fR it has to take a guess at which its dealing with
based what it finds just after the \f(CW\*(C`{\*(C'\fR. Usually it gets it right, but if it
doesn't it won't realize something is wrong until it gets to the \f(CW\*(C`}\*(C'\fR and
encounters the missing (or unexpected) comma. The syntax error will be
reported close to the \f(CW\*(C`}\*(C'\fR but you'll need to change something near the \f(CW\*(C`{\*(C'\fR
such as using a unary \f(CW\*(C`+\*(C'\fR to give perl some help:
.Sp
.Vb 5
\&    %hash = map {  "\eL$_", 1  } @array  # perl guesses EXPR.  wrong
\&    %hash = map { +"\eL$_", 1  } @array  # perl guesses BLOCK. right
\&    %hash = map { ("\eL$_", 1) } @array  # this also works
\&    %hash = map {  lc($_), 1  } @array  # as does this.
\&    %hash = map +( lc($_), 1 ), @array  # this is EXPR and works!
.Ve
.Sp
.Vb 1
\&    %hash = map  ( lc($_), 1 ), @array  # evaluates to (1, @array)
.Ve
.Sp
or to force an anon hash constructor use \f(CW\*(C`+{\*(C'\fR
.Sp
.Vb 1
\&   @hashes = map +{ lc($_), 1 }, @array # EXPR, so needs , at end
.Ve
.Sp
and you get list of anonymous hashes each with only 1 entry.
.IP "mkdir \s-1FILENAME\s0,MASK" 8
.IX Xref "mkdir md directory, create"
.IX Item "mkdir FILENAME,MASK"
.PD 0
.IP "mkdir \s-1FILENAME\s0" 8
.IX Item "mkdir FILENAME"
.PD
Creates the directory specified by \s-1FILENAME\s0, with permissions
specified by \s-1MASK\s0 (as modified by \f(CW\*(C`umask\*(C'\fR).  If it succeeds it
returns true, otherwise it returns false and sets \f(CW$!\fR (errno).
If omitted, \s-1MASK\s0 defaults to 0777.
.Sp
In general, it is better to create directories with permissive \s-1MASK\s0,
and let the user modify that with their \f(CW\*(C`umask\*(C'\fR, than it is to supply
a restrictive \s-1MASK\s0 and give the user no way to be more permissive.
The exceptions to this rule are when the file or directory should be
kept private (mail files, for instance).  The \fIperlfunc\fR\|(1) entry on
\&\f(CW\*(C`umask\*(C'\fR discusses the choice of \s-1MASK\s0 in more detail.
.Sp
Note that according to the \s-1POSIX\s0 1003.1\-1996 the \s-1FILENAME\s0 may have any
number of trailing slashes.  Some operating and filesystems do not get
this right, so Perl automatically removes all trailing slashes to keep
everyone happy.
.IP "msgctl \s-1ID\s0,CMD,ARG" 8
.IX Xref "msgctl"
.IX Item "msgctl ID,CMD,ARG"
Calls the System V \s-1IPC\s0 function \fImsgctl\fR\|(2).  You'll probably have to say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
.Sp
first to get the correct constant definitions.  If \s-1CMD\s0 is \f(CW\*(C`IPC_STAT\*(C'\fR,
then \s-1ARG\s0 must be a variable that will hold the returned \f(CW\*(C`msqid_ds\*(C'\fR
structure.  Returns like \f(CW\*(C`ioctl\*(C'\fR: the undefined value for error,
\&\f(CW"0 but true"\fR for zero, or the actual return value otherwise.  See also
\&\*(L"SysV \s-1IPC\s0\*(R" in perlipc, \f(CW\*(C`IPC::SysV\*(C'\fR, and \f(CW\*(C`IPC::Semaphore\*(C'\fR documentation.
.IP "msgget \s-1KEY\s0,FLAGS" 8
.IX Xref "msgget"
.IX Item "msgget KEY,FLAGS"
Calls the System V \s-1IPC\s0 function \fImsgget\fR\|(2).  Returns the message queue
id, or the undefined value if there is an error.  See also
\&\*(L"SysV \s-1IPC\s0\*(R" in perlipc and \f(CW\*(C`IPC::SysV\*(C'\fR and \f(CW\*(C`IPC::Msg\*(C'\fR documentation.
.IP "msgrcv \s-1ID\s0,VAR,SIZE,TYPE,FLAGS" 8
.IX Xref "msgrcv"
.IX Item "msgrcv ID,VAR,SIZE,TYPE,FLAGS"
Calls the System V \s-1IPC\s0 function msgrcv to receive a message from
message queue \s-1ID\s0 into variable \s-1VAR\s0 with a maximum message size of
\&\s-1SIZE\s0.  Note that when a message is received, the message type as a
native long integer will be the first thing in \s-1VAR\s0, followed by the
actual message.  This packing may be opened with \f(CW\*(C`unpack("l! a*")\*(C'\fR.
Taints the variable.  Returns true if successful, or false if there is
an error.  See also \*(L"SysV \s-1IPC\s0\*(R" in perlipc, \f(CW\*(C`IPC::SysV\*(C'\fR, and
\&\f(CW\*(C`IPC::SysV::Msg\*(C'\fR documentation.
.IP "msgsnd \s-1ID\s0,MSG,FLAGS" 8
.IX Xref "msgsnd"
.IX Item "msgsnd ID,MSG,FLAGS"
Calls the System V \s-1IPC\s0 function msgsnd to send the message \s-1MSG\s0 to the
message queue \s-1ID\s0.  \s-1MSG\s0 must begin with the native long integer message
type, and be followed by the length of the actual message, and finally
the message itself.  This kind of packing can be achieved with
\&\f(CW\*(C`pack("l! a*", $type, $message)\*(C'\fR.  Returns true if successful,
or false if there is an error.  See also \f(CW\*(C`IPC::SysV\*(C'\fR
and \f(CW\*(C`IPC::SysV::Msg\*(C'\fR documentation.
.IP "my \s-1EXPR\s0" 8
.IX Xref "my"
.IX Item "my EXPR"
.PD 0
.IP "my \s-1TYPE\s0 \s-1EXPR\s0" 8
.IX Item "my TYPE EXPR"
.IP "my \s-1EXPR\s0 : \s-1ATTRS\s0" 8
.IX Item "my EXPR : ATTRS"
.IP "my \s-1TYPE\s0 \s-1EXPR\s0 : \s-1ATTRS\s0" 8
.IX Item "my TYPE EXPR : ATTRS"
.PD
A \f(CW\*(C`my\*(C'\fR declares the listed variables to be local (lexically) to the
enclosing block, file, or \f(CW\*(C`eval\*(C'\fR.  If more than one value is listed,
the list must be placed in parentheses.
.Sp
The exact semantics and interface of \s-1TYPE\s0 and \s-1ATTRS\s0 are still
evolving.  \s-1TYPE\s0 is currently bound to the use of \f(CW\*(C`fields\*(C'\fR pragma,
and attributes are handled using the \f(CW\*(C`attributes\*(C'\fR pragma, or starting
from Perl 5.8.0 also via the \f(CW\*(C`Attribute::Handlers\*(C'\fR module.  See
\&\*(L"Private Variables via \fImy()\fR\*(R" in perlsub for details, and fields,
attributes, and Attribute::Handlers.
.IP "next \s-1LABEL\s0" 8
.IX Xref "next continue"
.IX Item "next LABEL"
.PD 0
.IP "next" 8
.IX Item "next"
.PD
The \f(CW\*(C`next\*(C'\fR command is like the \f(CW\*(C`continue\*(C'\fR statement in C; it starts
the next iteration of the loop:
.Sp
.Vb 4
\&    LINE: while (<STDIN>) {
\&        next LINE if /^#/;      # discard comments
\&        #...
\&    }
.Ve
.Sp
Note that if there were a \f(CW\*(C`continue\*(C'\fR block on the above, it would get
executed even on discarded lines.  If the \s-1LABEL\s0 is omitted, the command
refers to the innermost enclosing loop.
.Sp
\&\f(CW\*(C`next\*(C'\fR cannot be used to exit a block which returns a value such as
\&\f(CW\*(C`eval {}\*(C'\fR, \f(CW\*(C`sub {}\*(C'\fR or \f(CW\*(C`do {}\*(C'\fR, and should not be used to exit
a \fIgrep()\fR or \fImap()\fR operation.
.Sp
Note that a block by itself is semantically identical to a loop
that executes once.  Thus \f(CW\*(C`next\*(C'\fR will exit such a block early.
.Sp
See also \*(L"continue\*(R" for an illustration of how \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, and
\&\f(CW\*(C`redo\*(C'\fR work.
.IP "no Module \s-1VERSION\s0 \s-1LIST\s0" 8
.IX Xref "no"
.IX Item "no Module VERSION LIST"
.PD 0
.IP "no Module \s-1VERSION\s0" 8
.IX Item "no Module VERSION"
.IP "no Module \s-1LIST\s0" 8
.IX Item "no Module LIST"
.IP "no Module" 8
.IX Item "no Module"
.PD
See the \f(CW\*(C`use\*(C'\fR function, which \f(CW\*(C`no\*(C'\fR is the opposite of.
.IP "oct \s-1EXPR\s0" 8
.IX Xref "oct octal hex hexadecimal binary bin"
.IX Item "oct EXPR"
.PD 0
.IP "oct" 8
.IX Item "oct"
.PD
Interprets \s-1EXPR\s0 as an octal string and returns the corresponding
value.  (If \s-1EXPR\s0 happens to start off with \f(CW\*(C`0x\*(C'\fR, interprets it as a
hex string.  If \s-1EXPR\s0 starts off with \f(CW\*(C`0b\*(C'\fR, it is interpreted as a
binary string.  Leading whitespace is ignored in all three cases.)
The following will handle decimal, binary, octal, and hex in the standard
Perl or C notation:
.Sp
.Vb 1
\&    $val = oct($val) if $val =~ /^0/;
.Ve
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.   To go the other way (produce a number
in octal), use \fIsprintf()\fR or \fIprintf()\fR:
.Sp
.Vb 2
\&    $perms = (stat("filename"))[2] & 07777;
\&    $oct_perms = sprintf "%lo", $perms;
.Ve
.Sp
The \fIoct()\fR function is commonly used when a string such as \f(CW644\fR needs
to be converted into a file mode, for example. (Although perl will
automatically convert strings into numbers as needed, this automatic
conversion assumes base 10.)
.IP "open \s-1FILEHANDLE\s0,EXPR" 8
.IX Xref "open pipe file, open fopen"
.IX Item "open FILEHANDLE,EXPR"
.PD 0
.IP "open \s-1FILEHANDLE\s0,MODE,EXPR" 8
.IX Item "open FILEHANDLE,MODE,EXPR"
.IP "open \s-1FILEHANDLE\s0,MODE,EXPR,LIST" 8
.IX Item "open FILEHANDLE,MODE,EXPR,LIST"
.IP "open \s-1FILEHANDLE\s0,MODE,REFERENCE" 8
.IX Item "open FILEHANDLE,MODE,REFERENCE"
.IP "open \s-1FILEHANDLE\s0" 8
.IX Item "open FILEHANDLE"
.PD

